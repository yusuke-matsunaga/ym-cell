				liberty 文法覚書

- 基本的な構文として
  * simple attribute
  * complex attribute
  * group statement
  の3種類がある．
  根本は library group statement でその下に再帰的に属性を持つ．


- simple attribute は
  <属性名> : <属性値> ;
  のシンタックスで表される．
  属性値としては
  * int
  * bool
  * float
  * string
  * expr
  がある．

  ただし，string 型の中には direction や technology の様に予め定められ
  た文字列しか受け付けないものもある．
  また，論理式は見かけは simple attribute だが，属性値の部分に空白を含
  むためパーサー的には別に扱う．
  ややこしいのは文字列中に式を書いた function 記述という型もある．
  こちらは一旦文字列としてパースしてから式に変換する．


- complex attribute は
  <属性名> ( <属性値1>, <属性値2>, ... ) ;
  のシンタックスで表される．
  属性値は simple attribute と同じ．ただし expr はない．
  個々の属性ごとに属性値の型は決まっている．

  こちらもめんどくさいのは見かけは一つの文字列だが，中が空白で区切られ
  た数値の場合がある(lookup table の values 属性等)．
  そのため特別なハンドラを用意する．


- group statement は
  <属性名> ( <属性値1>, <属性値2>, ... ) {
     <属性記述1>
     <属性記述2>
     ...
  }
  のシンタックスで表される．
  最初の行は行末の '{' 以外は complex attribute と同様である．
  属性記述には simple attribute, complex attribute, group statement が記述できる．

- 多くの属性はそのグループ内において唯一のみ定義される．

- 同じ属性名が複数現れるのは
  * library.wire_load
  * library.wire_load_selection
  * library.wire_load_table
  * library.lu_table_template
  * library.power_lut_template
  * library.operating_conditions
  * library.cell
  * cell.bus
  * cell.bundle
  * cell.pin
  * cell.internal_power
  * test_cell.pin
  * bus.pin
  * bundle.internal_power
  * bundle.pin
  * bundle.timing
  * pin.internal_power
  * pin.timing

- パーサーの基本構造としては simple attribute, complex attribute,
  group statement の各属性用のパース関数を作る．
  そのなかで個々の属性に応じた処理を行うため DotlibHandler
  というクラスを用いる．
  この DotlibHandler を継承したクラスが実際のパース処理を行う．

- パースした構文木を表すために AstNode というクラスを用意する．
  実際には AstNode の派生クラスの木構造で構文木を表す．

- simple attribute とそれに対応する AstNode の派生クラス
  * int                  -> AstInt
  * bool                 -> AstBool
  * float                -> AstFloat
  * string               -> AstString
  * expr                 -> AstExpr
  * function             -> AstExpr
  * 'clear_preset_var_n' -> AstCPType
  * 'delay_model'        -> AstDelayModel
  * 'direction'          -> AstPinDirection
  * 'technology'         -> AstTechnology
  * 'timing_sense'       -> AstTimingSense
  * 'timing_type'        -> AstTimingType
  * 'variable_type'      -> AstVarType


- complex attribute とそれに対応する AstNode の派生クラス
  * 'coefs'              -> AstFloatVector
  * (float, float)       -> (AstFloat, AstFloat)
  * 'index_n'            -> AstFloatVector
  * 'orders'             -> AstIntVector
  * 'piece wise'         -> AstPieceWise
  * 'unit'               -> AstUnit
  * 'values'             -> AstFloatVector
  * 'variable_n_range'   -> AstVariableRange


- group statement とそれに対応する AstNode の派生クラス
  * 'bus'                -> AstBus
  * 'bundle'             -> AstBundle
  * 'cell'               -> AstCell
  * 'cell_degradation'   -> AstCellDegradation
  * 'domain'             -> AstDomain
  * 'ff'                 -> AstFF
  * 'ff_bank'            -> AstFFBank
  * 'input_voltage'      -> AstInputVoltage
  * 'latch'              -> AstLatch
  * 'latch_bank'         -> AstLatchBank
  * 'library'            -> AstLibrary
  * 'lu_table'           -> AstLut
  * 'output_voltage'     -> AstOutputVoltage
  * 'pin'                -> AstPin
  * 'statetable'         -> AstStatetable
  * 'template'           -> AstTemplate
  * 'timing'             -> AstTiming


- AstXXX はコンストラクタで値を設定したらあとは const にしたいので，ビ
  ルダークラスを用意する．AstXXX を読み込む XXXHandler は一旦そのビル
  ダークラスのメンバに値を設定し，そのビルダークラスを AstXXX のコンス
  トラクタに渡す．
  このような二度手間にしている理由は２つ．
  * 可変長のリストをビルダクラス中では vector<> で保持しておいて
    AstXXX のコンストラクタでは固定長の配列として確保する．
  * パース途中でエラーが起こった場合に AstXXX のオブジェクトを確保
    しない．ビルダークラスのオブジェクトは自動変数として確保しておくの
    でエラー時には自動的に削除される．

- AstXXX, XXXHandler, ビルダークラスと関連した情報を持つのでもととなる
  データからこれらのクラスのヘッダファイルとソースファイルを自動生成す
  る Python スクリプトを用意する．
  一旦，ファイルを作ってしまえば仕様変更がない限り再度生成する必要はな
  いので，生成後のファイルに手直しをすることも可能．

- ビルダークラスの名前は TmpXXX とする．


- 以下，整理されていないおぼえ書き

- "ff" と ff は同じ

- include_file ( filename );
  結構，制限があるし，今はあまり使われていないみたい．

- current_unit は
  1uA, 10uA, 100uA, 1mA, 10mA, 100mA, 1A
  のいずれか．
  用例をみると "" つきとそうでないものがある．

- power_unit は
  1mW, 100uW, 10uW, 1uW, 100nW, 10nW, 1nW, 100pW, 10pW, 1pW
  のいずれか．
  用例をみると "" つきとそうでないものがある．

- resistance_unit は
  1ohm, 10ohm, 100ohm, 1kohm
  のいずれか．
  "" なしが認められるかは不明だがあると思った方がよい．

- revision の値は string or number といっているが，
  1.01a というのもあるので [0-9a-zA-Z.]* でいいのでは？
  もしくは非空白印字可能文字は全部含めてしまってもいいかも．

- time_unit は
  1ps, 10ps, 100ps, 1ns
  のいずれか．
  用例をみるかぎり "" なしもあるみたい．

- voltage_unit は
  1mV, 10mV, 100mV, 1V
  用例をみるかぎり "" なしもあるみたい．

- capacitive_unit は
  ff か pf

- input_voltage や output_voltage に出てくる expression は
  以下みたいな感じ？
  expression : float_number
  	     | 'VDD'
	     | 'VSS'
	     | 'VCC'
             | '(' expression ')'
	     | '+' expression
	     | '-' expression
	     | expression '+' expression
	     | expression '-' expression
	     | expression '*' expression
	     | expression '/' expression
