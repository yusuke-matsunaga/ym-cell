
/// @file AttrDic.cc
/// @brief AttrDic の実装ファイル
/// @author Yusuke Matsunaga (松永 裕介)
///
/// Copyright (C) 2018 Yusuke Matsunaga
/// All rights reserved.


#include "AttrDic.h"


BEGIN_NAMESPACE_YM_DOTLIB

//////////////////////////////////////////////////////////////////////
// クラス AttrDic
//////////////////////////////////////////////////////////////////////

// @brief コンストラクタ
AttrDic::AttrDic()
{
  // gen_attr_dic.py で作成
  mDic.add("area", AttrType::AREA);
  mDic.add("auxiliary_pad_cell", AttrType::AUXILIARY_PAD_CELL);
  mDic.add("base_name", AttrType::BASE_NAME);
  mDic.add("bit_width", AttrType::BIT_WIDTH);
  mDic.add("bundle", AttrType::BUNDLE);
  mDic.add("bus_naming_style", AttrType::BUS_NAMING_STYLE);
  mDic.add("bus_type", AttrType::BUS_TYPE);
  mDic.add("bus", AttrType::BUS);
  mDic.add("calc_mode", AttrType::CALC_MODE);
  mDic.add("capacitance", AttrType::CAPACITANCE);
  mDic.add("capacitive_load_unit", AttrType::CAPACITIVE_LOAD_UNIT);
  mDic.add("cell_degradation", AttrType::CELL_DEGRADATION);
  mDic.add("cell_fall", AttrType::CELL_FALL);
  mDic.add("cell_footprint", AttrType::CELL_FOOTPRINT);
  mDic.add("cell_leakage_power", AttrType::CELL_LEAKAGE_POWER);
  mDic.add("cell_rise", AttrType::CELL_RISE);
  mDic.add("cell", AttrType::CELL);
  mDic.add("clear_preset_var1", AttrType::CLEAR_PRESET_VAR1);
  mDic.add("clear_preset_var2", AttrType::CLEAR_PRESET_VAR2);
  mDic.add("clear", AttrType::CLEAR);
  mDic.add("clock_gate_clock_pin", AttrType::CLOCK_GATE_CLOCK_PIN);
  mDic.add("clock_gate_enable_pin", AttrType::CLOCK_GATE_ENABLE_PIN);
  mDic.add("clock_gate_test_pin", AttrType::CLOCK_GATE_TEST_PIN);
  mDic.add("clock_gate_obs_pin", AttrType::CLOCK_GATE_OBS_PIN);
  mDic.add("clock_gate_out_pin", AttrType::CLOCK_GATE_OUT_PIN);
  mDic.add("clock_gating_integrated_cell", AttrType::CLOCK_GATING_INTEGRATED_CELL);
  mDic.add("clock", AttrType::CLOCK);
  mDic.add("clocked_on_also", AttrType::CLOCKED_ON_ALSO);
  mDic.add("clocked_on", AttrType::CLOCKED_ON);
  mDic.add("coefs", AttrType::COEFS);
  mDic.add("comment", AttrType::COMMENT);
  mDic.add("complementary_pin", AttrType::COMPLEMENTARY_PIN);
  mDic.add("connection_class", AttrType::CONNECTION_CLASS);
  mDic.add("contention_condition", AttrType::CONTENTION_CONDITION);
  mDic.add("current_unit", AttrType::CURRENT_UNIT);
  mDic.add("data_in", AttrType::DATA_IN);
  mDic.add("date", AttrType::DATE);
  mDic.add("dc_current_template", AttrType::DC_CURRENT_TEMPLATE);
  mDic.add("default_cell_leakage_power", AttrType::DEFAULT_CELL_LEAKAGE_POWER);
  mDic.add("default_connection_class", AttrType::DEFAULT_CONNECTION_CLASS);
  mDic.add("default_fall_delay_intercept", AttrType::DEFAULT_FALL_DELAY_INTERCEPT);
  mDic.add("default_fall_pin_resistance", AttrType::DEFAULT_FALL_PIN_RESISTANCE);
  mDic.add("default_fanout_load", AttrType::DEFAULT_FANOUT_LOAD);
  mDic.add("default_inout_pin_cap", AttrType::DEFAULT_INOUT_PIN_CAP);
  mDic.add("default_inout_pin_fall_res", AttrType::DEFAULT_INOUT_PIN_FALL_RES);
  mDic.add("default_inout_pin_rise_res", AttrType::DEFAULT_INOUT_PIN_RISE_RES);
  mDic.add("default_input_pin_cap", AttrType::DEFAULT_INPUT_PIN_CAP);
  mDic.add("default_intrinsic_fall", AttrType::DEFAULT_INTRINSIC_FALL);
  mDic.add("default_intrinsic_rise", AttrType::DEFAULT_INTRINSIC_RISE);
  mDic.add("default_leakage_power_density", AttrType::DEFAULT_LEAKAGE_POWER_DENSITY);
  mDic.add("default_max_capacitance", AttrType::DEFAULT_MAX_CAPACITANCE);
  mDic.add("default_max_fanout", AttrType::DEFAULT_MAX_FANOUT);
  mDic.add("default_max_transition", AttrType::DEFAULT_MAX_TRANSITION);
  mDic.add("default_max_utilization", AttrType::DEFAULT_MAX_UTILIZATION);
  mDic.add("default_min_porosity", AttrType::DEFAULT_MIN_POROSITY);
  mDic.add("default_operating_conditions", AttrType::DEFAULT_OPERATING_CONDITIONS);
  mDic.add("default_output_pin_cap", AttrType::DEFAULT_OUTPUT_PIN_CAP);
  mDic.add("default_output_pin_fall_res", AttrType::DEFAULT_OUTPUT_PIN_FALL_RES);
  mDic.add("default_output_pin_rise_res", AttrType::DEFAULT_OUTPUT_PIN_RISE_RES);
  mDic.add("default_part", AttrType::DEFAULT_PART);
  mDic.add("default_rise_delay_intercept", AttrType::DEFAULT_RISE_DELAY_INTERCEPT);
  mDic.add("default_rise_pin_resistance", AttrType::DEFAULT_RISE_PIN_RESISTANCE);
  mDic.add("default_slope_fall", AttrType::DEFAULT_SLOPE_FALL);
  mDic.add("default_slope_rise", AttrType::DEFAULT_SLOPE_RISE);
  mDic.add("default_wire_load_area", AttrType::DEFAULT_WIRE_LOAD_AREA);
  mDic.add("default_wire_load_capacitance", AttrType::DEFAULT_WIRE_LOAD_CAPACITANCE);
  mDic.add("default_wire_load_mode", AttrType::DEFAULT_WIRE_LOAD_MODE);
  mDic.add("default_wire_load_resistance", AttrType::DEFAULT_WIRE_LOAD_RESISTANCE);
  mDic.add("default_wire_load_selection", AttrType::DEFAULT_WIRE_LOAD_SELECTION);
  mDic.add("default_wire_load", AttrType::DEFAULT_WIRE_LOAD);
  mDic.add("define_cell_area", AttrType::DEFINE_CELL_AREA);
  mDic.add("define_group", AttrType::DEFINE_GROUP);
  mDic.add("define", AttrType::DEFINE);
  mDic.add("delay_model", AttrType::DELAY_MODEL);
  mDic.add("direction", AttrType::DIRECTION);
  mDic.add("domain", AttrType::DOMAIN);
  mDic.add("dont_fault", AttrType::DONT_FAULT);
  mDic.add("dont_touch", AttrType::DONT_TOUCH);
  mDic.add("dont_use", AttrType::DONT_USE);
  mDic.add("drive_current", AttrType::DRIVE_CURRENT);
  mDic.add("driver_type", AttrType::DRIVER_TYPE);
  mDic.add("dynamic_current", AttrType::DYNAMIC_CURRENT);
  mDic.add("edge_rate_sensitivity_f0", AttrType::EDGE_RATE_SENSITIVITY_F0);
  mDic.add("edge_rate_sensitivity_f1", AttrType::EDGE_RATE_SENSITIVITY_F1);
  mDic.add("edge_rate_sensitivity_r0", AttrType::EDGE_RATE_SENSITIVITY_R0);
  mDic.add("edge_rate_sensitivity_r1", AttrType::EDGE_RATE_SENSITIVITY_R1);
  mDic.add("edif_name", AttrType::EDIF_NAME);
  mDic.add("electromigration", AttrType::ELECTROMIGRATION);
  mDic.add("em_lut_template", AttrType::EM_LUT_TEMPLATE);
  mDic.add("em_temp_degradation_factor", AttrType::EM_TEMP_DEGRADATION_FACTOR);
  mDic.add("enable_also", AttrType::ENABLE_ALSO);
  mDic.add("enable", AttrType::ENABLE);
  mDic.add("equal_or_opposite_output", AttrType::EQUAL_OR_OPPOSITE_OUTPUT);
  mDic.add("fall_capacitance_range", AttrType::FALL_CAPACITANCE_RANGE);
  mDic.add("fall_capacitance", AttrType::FALL_CAPACITANCE);
  mDic.add("fall_constraint", AttrType::FALL_CONSTRAINT);
  mDic.add("fall_current_slope_after_threshold", AttrType::FALL_CURRENT_SLOPE_AFTER_THRESHOLD);
  mDic.add("fall_current_slope_before_threshold", AttrType::FALL_CURRENT_SLOPE_BEFORE_THRESHOLD);
  mDic.add("fall_delay_intercept", AttrType::FALL_DELAY_INTERCEPT);
  mDic.add("fall_pin_resistance", AttrType::FALL_PIN_RESISTANCE);
  mDic.add("fall_power", AttrType::FALL_POWER);
  mDic.add("fall_propagation", AttrType::FALL_PROPAGATION);
  mDic.add("fall_resistance", AttrType::FALL_RESISTANCE);
  mDic.add("fall_time_after_threshold", AttrType::FALL_TIME_AFTER_THRESHOLD);
  mDic.add("fall_time_before_threshold", AttrType::FALL_TIME_BEFORE_THRESHOLD);
  mDic.add("fall_transition_degradation", AttrType::FALL_TRANSITION_DEGRADATION);
  mDic.add("fall_transition", AttrType::FALL_TRANSITION);
  mDic.add("falling_together_group", AttrType::FALLING_TOGETHER_GROUP);
  mDic.add("fanout_area", AttrType::FANOUT_AREA);
  mDic.add("fanout_capacitance", AttrType::FANOUT_CAPACITANCE);
  mDic.add("fanout_length", AttrType::FANOUT_LENGTH);
  mDic.add("fanout_load", AttrType::FANOUT_LOAD);
  mDic.add("fanout_resistance", AttrType::FANOUT_RESISTANCE);
  mDic.add("fault_model", AttrType::FAULT_MODEL);
  mDic.add("faults_lut_template", AttrType::FAULTS_LUT_TEMPLATE);
  mDic.add("ff_bank", AttrType::FF_BANK);
  mDic.add("ff", AttrType::FF);
  mDic.add("fpga_domain_style", AttrType::FPGA_DOMAIN_STYLE);
  mDic.add("fpga_technology", AttrType::FPGA_TECHNOLOGY);
  mDic.add("function", AttrType::FUNCTION);
  mDic.add("functional_yield_metric", AttrType::FUNCTIONAL_YIELD_METRIC);
  mDic.add("generated_clock", AttrType::GENERATED_CLOCK);
  mDic.add("geometry_print", AttrType::GEOMETRY_PRINT);
  mDic.add("handle_negative_constraint", AttrType::HANDLE_NEGATIVE_CONSTRAINT);
  mDic.add("has_builtin_pad", AttrType::HAS_BUILTIN_PAD);
  mDic.add("hyperbolic_noise_above_high", AttrType::HYPERBOLIC_NOISE_ABOVE_HIGH);
  mDic.add("hyperbolic_noise_below_low", AttrType::HYPERBOLIC_NOISE_BELOW_LOW);
  mDic.add("hyperbolic_noise_high", AttrType::HYPERBOLIC_NOISE_HIGH);
  mDic.add("hyperbolic_noise_low", AttrType::HYPERBOLIC_NOISE_LOW);
  mDic.add("hysteresis", AttrType::HYSTERESIS);
  mDic.add("in_place_swap_mode", AttrType::IN_PLACE_SWAP_MODE);
  mDic.add("index_1", AttrType::INDEX_1);
  mDic.add("index_2", AttrType::INDEX_2);
  mDic.add("index_3", AttrType::INDEX_3);
  mDic.add("input_map", AttrType::INPUT_MAP);
  mDic.add("input_signal_level", AttrType::INPUT_SIGNAL_LEVEL);
  mDic.add("input_threshold_pct_fall", AttrType::INPUT_THRESHOLD_PCT_FALL);
  mDic.add("input_threshold_pct_rise", AttrType::INPUT_THRESHOLD_PCT_RISE);
  mDic.add("input_voltage", AttrType::INPUT_VOLTAGE);
  mDic.add("interface_timing", AttrType::INTERFACE_TIMING);
  mDic.add("internal_node", AttrType::INTERNAL_NODE);
  mDic.add("internal_power", AttrType::INTERNAL_POWER);
  mDic.add("intrinsic_fall", AttrType::INTRINSIC_FALL);
  mDic.add("intrinsic_parasitic", AttrType::INTRINSIC_PARASITIC);
  mDic.add("intrinsic_rise", AttrType::INTRINSIC_RISE);
  mDic.add("inverted_output", AttrType::INVERTED_OUTPUT);
  mDic.add("io_type", AttrType::IO_TYPE);
  mDic.add("is_clock_gating_cell", AttrType::IS_CLOCK_GATING_CELL);
  mDic.add("is_filler_cell", AttrType::IS_FILLER_CELL);
  mDic.add("is_pad", AttrType::IS_PAD);
  mDic.add("iv_lut_template", AttrType::IV_LUT_TEMPLATE);
  mDic.add("k_process_cell_fall", AttrType::K_PROCESS_CELL_FALL);
  mDic.add("k_process_cell_leakage_power", AttrType::K_PROCESS_CELL_LEAKAGE_POWER);
  mDic.add("k_process_cell_rise", AttrType::K_PROCESS_CELL_RISE);
  mDic.add("k_process_drive_current", AttrType::K_PROCESS_DRIVE_CURRENT);
  mDic.add("k_process_drive_fall", AttrType::K_PROCESS_DRIVE_FALL);
  mDic.add("k_process_drive_rise", AttrType::K_PROCESS_DRIVE_RISE);
  mDic.add("k_process_fall_delay_intercept", AttrType::K_PROCESS_FALL_DELAY_INTERCEPT);
  mDic.add("k_process_fall_pin_resistance", AttrType::K_PROCESS_FALL_PIN_RESISTANCE);
  mDic.add("k_process_fall_propagation", AttrType::K_PROCESS_FALL_PROPAGATION);
  mDic.add("k_process_fall_transition", AttrType::K_PROCESS_FALL_TRANSITION);
  mDic.add("k_process_hold_fall", AttrType::K_PROCESS_HOLD_FALL);
  mDic.add("k_process_hold_rise", AttrType::K_PROCESS_HOLD_RISE);
  mDic.add("k_process_internal_power", AttrType::K_PROCESS_INTERNAL_POWER);
  mDic.add("k_process_intrinsic_fall", AttrType::K_PROCESS_INTRINSIC_FALL);
  mDic.add("k_process_intrinsic_rise", AttrType::K_PROCESS_INTRINSIC_RISE);
  mDic.add("k_process_min_period", AttrType::K_PROCESS_MIN_PERIOD);
  mDic.add("k_process_min_pulse_width_high", AttrType::K_PROCESS_MIN_PULSE_WIDTH_HIGH);
  mDic.add("k_process_min_pulse_width_low", AttrType::K_PROCESS_MIN_PULSE_WIDTH_LOW);
  mDic.add("k_process_nochange_fall", AttrType::K_PROCESS_NOCHANGE_FALL);
  mDic.add("k_process_nochange_rise", AttrType::K_PROCESS_NOCHANGE_RISE);
  mDic.add("k_process_pin_cap", AttrType::K_PROCESS_PIN_CAP);
  mDic.add("k_process_recovery_fall", AttrType::K_PROCESS_RECOVERY_FALL);
  mDic.add("k_process_recovery_rise", AttrType::K_PROCESS_RECOVERY_RISE);
  mDic.add("k_process_removal_fall", AttrType::K_PROCESS_REMOVAL_FALL);
  mDic.add("k_process_removal_rise", AttrType::K_PROCESS_REMOVAL_RISE);
  mDic.add("k_process_rise_transition", AttrType::K_PROCESS_RISE_TRANSITION);
  mDic.add("k_process_rise_delay_intercept", AttrType::K_PROCESS_RISE_DELAY_INTERCEPT);
  mDic.add("k_process_rise_pin_resistance", AttrType::K_PROCESS_RISE_PIN_RESISTANCE);
  mDic.add("k_process_rise_propagation", AttrType::K_PROCESS_RISE_PROPAGATION);
  mDic.add("k_process_setup_fall", AttrType::K_PROCESS_SETUP_FALL);
  mDic.add("k_process_setup_rise", AttrType::K_PROCESS_SETUP_RISE);
  mDic.add("k_process_skew_fall", AttrType::K_PROCESS_SKEW_FALL);
  mDic.add("k_process_skew_rise", AttrType::K_PROCESS_SKEW_RISE);
  mDic.add("k_process_slope_fall", AttrType::K_PROCESS_SLOPE_FALL);
  mDic.add("k_process_slope_rise", AttrType::K_PROCESS_SLOPE_RISE);
  mDic.add("k_process_wire_cap", AttrType::K_PROCESS_WIRE_CAP);
  mDic.add("k_process_wire_res", AttrType::K_PROCESS_WIRE_RES);
  mDic.add("k_temp_cell_fall", AttrType::K_TEMP_CELL_FALL);
  mDic.add("k_temp_cell_leakage_power", AttrType::K_TEMP_CELL_LEAKAGE_POWER);
  mDic.add("k_temp_cell_rise", AttrType::K_TEMP_CELL_RISE);
  mDic.add("k_temp_drive_current", AttrType::K_TEMP_DRIVE_CURRENT);
  mDic.add("k_temp_drive_fall", AttrType::K_TEMP_DRIVE_FALL);
  mDic.add("k_temp_drive_rise", AttrType::K_TEMP_DRIVE_RISE);
  mDic.add("k_temp_fall_delay_intercept", AttrType::K_TEMP_FALL_DELAY_INTERCEPT);
  mDic.add("k_temp_fall_pin_resistance", AttrType::K_TEMP_FALL_PIN_RESISTANCE);
  mDic.add("k_temp_fall_propagation", AttrType::K_TEMP_FALL_PROPAGATION);
  mDic.add("k_temp_fall_transition", AttrType::K_TEMP_FALL_TRANSITION);
  mDic.add("k_temp_hold_fall", AttrType::K_TEMP_HOLD_FALL);
  mDic.add("k_temp_hold_rise", AttrType::K_TEMP_HOLD_RISE);
  mDic.add("k_temp_internal_power", AttrType::K_TEMP_INTERNAL_POWER);
  mDic.add("k_temp_intrinsic_fall", AttrType::K_TEMP_INTRINSIC_FALL);
  mDic.add("k_temp_intrinsic_rise", AttrType::K_TEMP_INTRINSIC_RISE);
  mDic.add("k_temp_min_period", AttrType::K_TEMP_MIN_PERIOD);
  mDic.add("k_temp_min_pulse_width_high", AttrType::K_TEMP_MIN_PULSE_WIDTH_HIGH);
  mDic.add("k_temp_min_pulse_width_low", AttrType::K_TEMP_MIN_PULSE_WIDTH_LOW);
  mDic.add("k_temp_nochange_fall", AttrType::K_TEMP_NOCHANGE_FALL);
  mDic.add("k_temp_nochange_rise", AttrType::K_TEMP_NOCHANGE_RISE);
  mDic.add("k_temp_pin_cap", AttrType::K_TEMP_PIN_CAP);
  mDic.add("k_temp_recovery_fall", AttrType::K_TEMP_RECOVERY_FALL);
  mDic.add("k_temp_recovery_rise", AttrType::K_TEMP_RECOVERY_RISE);
  mDic.add("k_temp_removal_fall", AttrType::K_TEMP_REMOVAL_FALL);
  mDic.add("k_temp_removal_rise", AttrType::K_TEMP_REMOVAL_RISE);
  mDic.add("k_temp_rise_transition", AttrType::K_TEMP_RISE_TRANSITION);
  mDic.add("k_temp_rise_delay_intercept", AttrType::K_TEMP_RISE_DELAY_INTERCEPT);
  mDic.add("k_temp_rise_pin_resistance", AttrType::K_TEMP_RISE_PIN_RESISTANCE);
  mDic.add("k_temp_rise_propagation", AttrType::K_TEMP_RISE_PROPAGATION);
  mDic.add("k_temp_setup_fall", AttrType::K_TEMP_SETUP_FALL);
  mDic.add("k_temp_setup_rise", AttrType::K_TEMP_SETUP_RISE);
  mDic.add("k_temp_skew_fall", AttrType::K_TEMP_SKEW_FALL);
  mDic.add("k_temp_skew_rise", AttrType::K_TEMP_SKEW_RISE);
  mDic.add("k_temp_slope_fall", AttrType::K_TEMP_SLOPE_FALL);
  mDic.add("k_temp_slope_rise", AttrType::K_TEMP_SLOPE_RISE);
  mDic.add("k_temp_wire_cap", AttrType::K_TEMP_WIRE_CAP);
  mDic.add("k_temp_wire_res", AttrType::K_TEMP_WIRE_RES);
  mDic.add("k_volt_cell_fall", AttrType::K_VOLT_CELL_FALL);
  mDic.add("k_volt_cell_leakage_power", AttrType::K_VOLT_CELL_LEAKAGE_POWER);
  mDic.add("k_volt_cell_rise", AttrType::K_VOLT_CELL_RISE);
  mDic.add("k_volt_drive_current", AttrType::K_VOLT_DRIVE_CURRENT);
  mDic.add("k_volt_drive_fall", AttrType::K_VOLT_DRIVE_FALL);
  mDic.add("k_volt_drive_rise", AttrType::K_VOLT_DRIVE_RISE);
  mDic.add("k_volt_fall_delay_intercept", AttrType::K_VOLT_FALL_DELAY_INTERCEPT);
  mDic.add("k_volt_fall_pin_resistance", AttrType::K_VOLT_FALL_PIN_RESISTANCE);
  mDic.add("k_volt_fall_propagation", AttrType::K_VOLT_FALL_PROPAGATION);
  mDic.add("k_volt_fall_transition", AttrType::K_VOLT_FALL_TRANSITION);
  mDic.add("k_volt_hold_fall", AttrType::K_VOLT_HOLD_FALL);
  mDic.add("k_volt_hold_rise", AttrType::K_VOLT_HOLD_RISE);
  mDic.add("k_volt_internal_power", AttrType::K_VOLT_INTERNAL_POWER);
  mDic.add("k_volt_intrinsic_fall", AttrType::K_VOLT_INTRINSIC_FALL);
  mDic.add("k_volt_intrinsic_rise", AttrType::K_VOLT_INTRINSIC_RISE);
  mDic.add("k_volt_min_period", AttrType::K_VOLT_MIN_PERIOD);
  mDic.add("k_volt_min_pulse_width_high", AttrType::K_VOLT_MIN_PULSE_WIDTH_HIGH);
  mDic.add("k_volt_min_pulse_width_low", AttrType::K_VOLT_MIN_PULSE_WIDTH_LOW);
  mDic.add("k_volt_nochange_fall", AttrType::K_VOLT_NOCHANGE_FALL);
  mDic.add("k_volt_nochange_rise", AttrType::K_VOLT_NOCHANGE_RISE);
  mDic.add("k_volt_pin_cap", AttrType::K_VOLT_PIN_CAP);
  mDic.add("k_volt_recovery_fall", AttrType::K_VOLT_RECOVERY_FALL);
  mDic.add("k_volt_recovery_rise", AttrType::K_VOLT_RECOVERY_RISE);
  mDic.add("k_volt_removal_fall", AttrType::K_VOLT_REMOVAL_FALL);
  mDic.add("k_volt_removal_rise", AttrType::K_VOLT_REMOVAL_RISE);
  mDic.add("k_volt_rise_transition", AttrType::K_VOLT_RISE_TRANSITION);
  mDic.add("k_volt_rise_delay_intercept", AttrType::K_VOLT_RISE_DELAY_INTERCEPT);
  mDic.add("k_volt_rise_pin_resistance", AttrType::K_VOLT_RISE_PIN_RESISTANCE);
  mDic.add("k_volt_rise_propagation", AttrType::K_VOLT_RISE_PROPAGATION);
  mDic.add("k_volt_setup_fall", AttrType::K_VOLT_SETUP_FALL);
  mDic.add("k_volt_setup_rise", AttrType::K_VOLT_SETUP_RISE);
  mDic.add("k_volt_skew_fall", AttrType::K_VOLT_SKEW_FALL);
  mDic.add("k_volt_skew_rise", AttrType::K_VOLT_SKEW_RISE);
  mDic.add("k_volt_slope_fall", AttrType::K_VOLT_SLOPE_FALL);
  mDic.add("k_volt_slope_rise", AttrType::K_VOLT_SLOPE_RISE);
  mDic.add("k_volt_wire_cap", AttrType::K_VOLT_WIRE_CAP);
  mDic.add("k_volt_wire_res", AttrType::K_VOLT_WIRE_RES);
  mDic.add("latch_bank", AttrType::LATCH_BANK);
  mDic.add("latch", AttrType::LATCH);
  mDic.add("leakage_current", AttrType::LEAKAGE_CURRENT);
  mDic.add("leakage_power_unit", AttrType::LEAKAGE_POWER_UNIT);
  mDic.add("leakage_power", AttrType::LEAKAGE_POWER);
  mDic.add("library_features", AttrType::LIBRARY_FEATURES);
  mDic.add("library", AttrType::LIBRARY);
  mDic.add("lu_table_template", AttrType::LU_TABLE_TEMPLATE);
  mDic.add("lut", AttrType::LUT);
  mDic.add("map_only", AttrType::MAP_ONLY);
  mDic.add("max_capacitance", AttrType::MAX_CAPACITANCE);
  mDic.add("max_fanout", AttrType::MAX_FANOUT);
  mDic.add("max_input_noise_width", AttrType::MAX_INPUT_NOISE_WIDTH);
  mDic.add("max_trans", AttrType::MAX_TRANS);
  mDic.add("max_transition", AttrType::MAX_TRANSITION);
  mDic.add("members", AttrType::MEMBERS);
  mDic.add("min_capacitance", AttrType::MIN_CAPACITANCE);
  mDic.add("min_fanout", AttrType::MIN_FANOUT);
  mDic.add("min_input_noise_width", AttrType::MIN_INPUT_NOISE_WIDTH);
  mDic.add("min_period", AttrType::MIN_PERIOD);
  mDic.add("min_pulse_width_high", AttrType::MIN_PULSE_WIDTH_HIGH);
  mDic.add("min_pulse_width_low", AttrType::MIN_PULSE_WIDTH_LOW);
  mDic.add("min_pulse_width", AttrType::MIN_PULSE_WIDTH);
  mDic.add("min_transition", AttrType::MIN_TRANSITION);
  mDic.add("minimum_period", AttrType::MINIMUM_PERIOD);
  mDic.add("mode_definition", AttrType::MODE_DEFINITION);
  mDic.add("multicell_pad_pin", AttrType::MULTICELL_PAD_PIN);
  mDic.add("next_state", AttrType::NEXT_STATE);
  mDic.add("nextstate_type", AttrType::NEXTSTATE_TYPE);
  mDic.add("noise_immunity_above_high", AttrType::NOISE_IMMUNITY_ABOVE_HIGH);
  mDic.add("noise_immunity_below_low", AttrType::NOISE_IMMUNITY_BELOW_LOW);
  mDic.add("noise_immunity_high", AttrType::NOISE_IMMUNITY_HIGH);
  mDic.add("noise_immunity_low", AttrType::NOISE_IMMUNITY_LOW);
  mDic.add("noise_lut_template", AttrType::NOISE_LUT_TEMPLATE);
  mDic.add("nom_calc_mode", AttrType::NOM_CALC_MODE);
  mDic.add("nom_process", AttrType::NOM_PROCESS);
  mDic.add("nom_temperature", AttrType::NOM_TEMPERATURE);
  mDic.add("nom_voltage", AttrType::NOM_VOLTAGE);
  mDic.add("operating_conditions", AttrType::OPERATING_CONDITIONS);
  mDic.add("orders", AttrType::ORDERS);
  mDic.add("output_current_template", AttrType::OUTPUT_CURRENT_TEMPLATE);
  mDic.add("output_signal_level", AttrType::OUTPUT_SIGNAL_LEVEL);
  mDic.add("output_threshold_pct_fall", AttrType::OUTPUT_THRESHOLD_PCT_FALL);
  mDic.add("output_threshold_pct_rise", AttrType::OUTPUT_THRESHOLD_PCT_RISE);
  mDic.add("output_voltage", AttrType::OUTPUT_VOLTAGE);
  mDic.add("pad_cell", AttrType::PAD_CELL);
  mDic.add("pad_type", AttrType::PAD_TYPE);
  mDic.add("parameter1", AttrType::PARAMETER1);
  mDic.add("parameter2", AttrType::PARAMETER2);
  mDic.add("parameter3", AttrType::PARAMETER3);
  mDic.add("parameter4", AttrType::PARAMETER4);
  mDic.add("parameter5", AttrType::PARAMETER5);
  mDic.add("part", AttrType::PART);
  mDic.add("piece_define", AttrType::PIECE_DEFINE);
  mDic.add("piece_type", AttrType::PIECE_TYPE);
  mDic.add("pin_func_type", AttrType::PIN_FUNC_TYPE);
  mDic.add("pin_opposite", AttrType::PIN_OPPOSITE);
  mDic.add("pin", AttrType::PIN);
  mDic.add("poly_template", AttrType::POLY_TEMPLATE);
  mDic.add("power_cell_type", AttrType::POWER_CELL_TYPE);
  mDic.add("power_level", AttrType::POWER_LEVEL);
  mDic.add("power_lut_template", AttrType::POWER_LUT_TEMPLATE);
  mDic.add("power_poly_template", AttrType::POWER_POLY_TEMPLATE);
  mDic.add("power_model", AttrType::POWER_MODEL);
  mDic.add("power_rail", AttrType::POWER_RAIL);
  mDic.add("power_supply_namestring", AttrType::POWER_SUPPLY_NAMESTRING);
  mDic.add("power_supply", AttrType::POWER_SUPPLY);
  mDic.add("power", AttrType::POWER);
  mDic.add("prefer_tied", AttrType::PREFER_TIED);
  mDic.add("preferred", AttrType::PREFERRED);
  mDic.add("preferred_input_pad_voltage", AttrType::PREFERRED_INPUT_PAD_VOLTAGE);
  mDic.add("preferred_output_pad_slew_rate_control", AttrType::PREFERRED_OUTPUT_PAD_SLEW_RATE_CONTROL);
  mDic.add("preferred_output_pad_voltage", AttrType::PREFERRED_OUTPUT_PAD_VOLTAGE);
  mDic.add("preset", AttrType::PRESET);
  mDic.add("primary_output", AttrType::PRIMARY_OUTPUT);
  mDic.add("process", AttrType::PROCESS);
  mDic.add("propagated_noise_height_above_high", AttrType::PROPAGATED_NOISE_HEIGHT_ABOVE_HIGH);
  mDic.add("propagated_noise_height_below_low", AttrType::PROPAGATED_NOISE_HEIGHT_BELOW_LOW);
  mDic.add("propagated_noise_height_high", AttrType::PROPAGATED_NOISE_HEIGHT_HIGH);
  mDic.add("propagated_noise_height_low", AttrType::PROPAGATED_NOISE_HEIGHT_LOW);
  mDic.add("propagated_noise_peak_time_ratio_above_high", AttrType::PROPAGATED_NOISE_PEAK_TIME_RATIO_ABOVE_HIGH);
  mDic.add("propagated_noise_peak_time_ratio_below_low", AttrType::PROPAGATED_NOISE_PEAK_TIME_RATIO_BELOW_LOW);
  mDic.add("propagated_noise_peak_time_ratio_high", AttrType::PROPAGATED_NOISE_PEAK_TIME_RATIO_HIGH);
  mDic.add("propagated_noise_peak_time_ratio_low", AttrType::PROPAGATED_NOISE_PEAK_TIME_RATIO_LOW);
  mDic.add("propagated_noise_width_above_high", AttrType::PROPAGATED_NOISE_WIDTH_ABOVE_HIGH);
  mDic.add("propagated_noise_width_below_low", AttrType::PROPAGATED_NOISE_WIDTH_BELOW_LOW);
  mDic.add("propagated_noise_width_high", AttrType::PROPAGATED_NOISE_WIDTH_HIGH);
  mDic.add("propagated_noise_width_low", AttrType::PROPAGATED_NOISE_WIDTH_LOW);
  mDic.add("propagation_lut_template", AttrType::PROPAGATION_LUT_TEMPLATE);
  mDic.add("pulling_current", AttrType::PULLING_CURRENT);
  mDic.add("pulling_resistance_unit", AttrType::PULLING_RESISTANCE_UNIT);
  mDic.add("pulling_resistance", AttrType::PULLING_RESISTANCE);
  mDic.add("rail_connection", AttrType::RAIL_CONNECTION);
  mDic.add("related_bus_equivalent", AttrType::RELATED_BUS_EQUIVALENT);
  mDic.add("related_bus_pins", AttrType::RELATED_BUS_PINS);
  mDic.add("related_inputs", AttrType::RELATED_INPUTS);
  mDic.add("related_output_pin", AttrType::RELATED_OUTPUT_PIN);
  mDic.add("related_outputs", AttrType::RELATED_OUTPUTS);
  mDic.add("related_pg_pin", AttrType::RELATED_PG_PIN);
  mDic.add("related_pin", AttrType::RELATED_PIN);
  mDic.add("resistance", AttrType::RESISTANCE);
  mDic.add("resource_usage", AttrType::RESOURCE_USAGE);
  mDic.add("retain_fall_slew", AttrType::RETAIN_FALL_SLEW);
  mDic.add("retain_rise_slew", AttrType::RETAIN_RISE_SLEW);
  mDic.add("retaining_fall", AttrType::RETAINING_FALL);
  mDic.add("retaining_rise", AttrType::RETAINING_RISE);
  mDic.add("revision", AttrType::REVISION);
  mDic.add("rise_capacitance_range", AttrType::RISE_CAPACITANCE_RANGE);
  mDic.add("rise_capacitance", AttrType::RISE_CAPACITANCE);
  mDic.add("rise_constraint", AttrType::RISE_CONSTRAINT);
  mDic.add("rise_current_slope_after_threshold", AttrType::RISE_CURRENT_SLOPE_AFTER_THRESHOLD);
  mDic.add("rise_current_slope_before_threshold", AttrType::RISE_CURRENT_SLOPE_BEFORE_THRESHOLD);
  mDic.add("rise_delay_intercept", AttrType::RISE_DELAY_INTERCEPT);
  mDic.add("rise_pin_resistance", AttrType::RISE_PIN_RESISTANCE);
  mDic.add("rise_power", AttrType::RISE_POWER);
  mDic.add("rise_propagation", AttrType::RISE_PROPAGATION);
  mDic.add("rise_resistance", AttrType::RISE_RESISTANCE);
  mDic.add("rise_time_after_threshold", AttrType::RISE_TIME_AFTER_THRESHOLD);
  mDic.add("rise_time_before_threshold", AttrType::RISE_TIME_BEFORE_THRESHOLD);
  mDic.add("rise_transition_degradation", AttrType::RISE_TRANSITION_DEGRADATION);
  mDic.add("rise_transition", AttrType::RISE_TRANSITION);
  mDic.add("rising_together_group", AttrType::RISING_TOGETHER_GROUP);
  mDic.add("routing_layers", AttrType::ROUTING_LAYERS);
  mDic.add("routing_track", AttrType::ROUTING_TRACK);
  mDic.add("scaled_cell", AttrType::SCALED_CELL);
  mDic.add("scaling_factors", AttrType::SCALING_FACTORS);
  mDic.add("sdf_cond_end", AttrType::SDF_COND_END);
  mDic.add("sdf_cond_start", AttrType::SDF_COND_START);
  mDic.add("sdf_cond", AttrType::SDF_COND);
  mDic.add("sdf_edges", AttrType::SDF_EDGES);
  mDic.add("signal_type", AttrType::SIGNAL_TYPE);
  mDic.add("simulation", AttrType::SIMULATION);
  mDic.add("single_bit_degenerate", AttrType::SINGLE_BIT_DEGENERATE);
  mDic.add("slew_control", AttrType::SLEW_CONTROL);
  mDic.add("slew_derate_from_library", AttrType::SLEW_DERATE_FROM_LIBRARY);
  mDic.add("slew_lower_threshold_pct_fall", AttrType::SLEW_LOWER_THRESHOLD_PCT_FALL);
  mDic.add("slew_lower_threshold_pct_rise", AttrType::SLEW_LOWER_THRESHOLD_PCT_RISE);
  mDic.add("slew_type", AttrType::SLEW_TYPE);
  mDic.add("slew_upper_threshold_pct_fall", AttrType::SLEW_UPPER_THRESHOLD_PCT_FALL);
  mDic.add("slew_upper_threshold_pct_rise", AttrType::SLEW_UPPER_THRESHOLD_PCT_RISE);
  mDic.add("slope_fall", AttrType::SLOPE_FALL);
  mDic.add("slope_rise", AttrType::SLOPE_RISE);
  mDic.add("slope", AttrType::SLOPE);
  mDic.add("state_function", AttrType::STATE_FUNCTION);
  mDic.add("statetable", AttrType::STATETABLE);
  mDic.add("steady_state_current_high", AttrType::STEADY_STATE_CURRENT_HIGH);
  mDic.add("steady_state_current_low", AttrType::STEADY_STATE_CURRENT_LOW);
  mDic.add("steady_state_current_tristate", AttrType::STEADY_STATE_CURRENT_TRISTATE);
  mDic.add("switching_interval", AttrType::SWITCHING_INTERVAL);
  mDic.add("switching_together_group", AttrType::SWITCHING_TOGETHER_GROUP);
  mDic.add("table", AttrType::TABLE);
  mDic.add("technology", AttrType::TECHNOLOGY);
  mDic.add("temperature", AttrType::TEMPERATURE);
  mDic.add("test_cell", AttrType::TEST_CELL);
  mDic.add("test_output_only", AttrType::TEST_OUTPUT_ONLY);
  mDic.add("three_state", AttrType::THREE_STATE);
  mDic.add("time_unit", AttrType::TIME_UNIT);
  mDic.add("timing_model_type", AttrType::TIMING_MODEL_TYPE);
  mDic.add("timing_range", AttrType::TIMING_RANGE);
  mDic.add("timing_sense", AttrType::TIMING_SENSE);
  mDic.add("timing_type", AttrType::TIMING_TYPE);
  mDic.add("timing", AttrType::TIMING);
  mDic.add("tlatch", AttrType::TLATCH);
  mDic.add("tree_type", AttrType::TREE_TYPE);
  mDic.add("type", AttrType::TYPE);
  mDic.add("use_for_size_only", AttrType::USE_FOR_SIZE_ONLY);
  mDic.add("value", AttrType::VALUE);
  mDic.add("values", AttrType::VALUES);
  mDic.add("variable_1", AttrType::VARIABLE_1);
  mDic.add("variable_2", AttrType::VARIABLE_2);
  mDic.add("variable_3", AttrType::VARIABLE_3);
  mDic.add("vhdl_name", AttrType::VHDL_NAME);
  mDic.add("vih", AttrType::VIH);
  mDic.add("vil", AttrType::VIL);
  mDic.add("vimax", AttrType::VIMAX);
  mDic.add("vimin", AttrType::VIMIN);
  mDic.add("voh", AttrType::VOH);
  mDic.add("vol", AttrType::VOL);
  mDic.add("voltage_unit", AttrType::VOLTAGE_UNIT);
  mDic.add("voltage", AttrType::VOLTAGE);
  mDic.add("vomax", AttrType::VOMAX);
  mDic.add("vomin", AttrType::VOMIN);
  mDic.add("when_end", AttrType::WHEN_END);
  mDic.add("when_start", AttrType::WHEN_START);
  mDic.add("when", AttrType::WHEN);
  mDic.add("wire_load_from_area", AttrType::WIRE_LOAD_FROM_AREA);
  mDic.add("wire_load_selection", AttrType::WIRE_LOAD_SELECTION);
  mDic.add("wire_load_table", AttrType::WIRE_LOAD_TABLE);
  mDic.add("wire_load", AttrType::WIRE_LOAD);
  mDic.add("x_function", AttrType::X_FUNCTION);
}

// @brief デストラクタ
AttrDic::~AttrDic()
{
}

// @brief 文字列を属性値に変換する．
// @param[in] str 文字列
// @return str に対応する AttrType の値
//
// 対応する値がない場合は AttrType::NONE を返す．
AttrType
AttrDic::get(const char* str) const
{
  if ( mDic.check(str) ) {
    return mDic[str];
  }
  else {
    return AttrType::NONE;
  }
}

// @brief AttrType の内容をストリームに出力する．
ostream&
operator<<(ostream& s,
	   AttrType attr)
{
  switch ( attr ) {
  case AttrType::NONE: s << "none"; break;
  case AttrType::AREA: s << "area"; break;
  case AttrType::AUXILIARY_PAD_CELL: s << "auxiliary_pad_cell"; break;
  case AttrType::BASE_NAME: s << "base_name"; break;
  case AttrType::BIT_WIDTH: s << "bit_width"; break;
  case AttrType::BUNDLE: s << "bundle"; break;
  case AttrType::BUS_NAMING_STYLE: s << "bus_naming_style"; break;
  case AttrType::BUS_TYPE: s << "bus_type"; break;
  case AttrType::BUS: s << "bus"; break;
  case AttrType::CALC_MODE: s << "calc_mode"; break;
  case AttrType::CAPACITANCE: s << "capacitance"; break;
  case AttrType::CAPACITIVE_LOAD_UNIT: s << "capacitive_load_unit"; break;
  case AttrType::CELL_DEGRADATION: s << "cell_degradation"; break;
  case AttrType::CELL_FALL: s << "cell_fall"; break;
  case AttrType::CELL_FOOTPRINT: s << "cell_footprint"; break;
  case AttrType::CELL_LEAKAGE_POWER: s << "cell_leakage_power"; break;
  case AttrType::CELL_RISE: s << "cell_rise"; break;
  case AttrType::CELL: s << "cell"; break;
  case AttrType::CLEAR_PRESET_VAR1: s << "clear_preset_var1"; break;
  case AttrType::CLEAR_PRESET_VAR2: s << "clear_preset_var2"; break;
  case AttrType::CLEAR: s << "clear"; break;
  case AttrType::CLOCK_GATE_CLOCK_PIN: s << "clock_gate_clock_pin"; break;
  case AttrType::CLOCK_GATE_ENABLE_PIN: s << "clock_gate_enable_pin"; break;
  case AttrType::CLOCK_GATE_TEST_PIN: s << "clock_gate_test_pin"; break;
  case AttrType::CLOCK_GATE_OBS_PIN: s << "clock_gate_obs_pin"; break;
  case AttrType::CLOCK_GATE_OUT_PIN: s << "clock_gate_out_pin"; break;
  case AttrType::CLOCK_GATING_INTEGRATED_CELL: s << "clock_gating_integrated_cell"; break;
  case AttrType::CLOCK: s << "clock"; break;
  case AttrType::CLOCKED_ON_ALSO: s << "clocked_on_also"; break;
  case AttrType::CLOCKED_ON: s << "clocked_on"; break;
  case AttrType::COEFS: s << "coefs"; break;
  case AttrType::COMMENT: s << "comment"; break;
  case AttrType::COMPLEMENTARY_PIN: s << "complementary_pin"; break;
  case AttrType::CONNECTION_CLASS: s << "connection_class"; break;
  case AttrType::CONTENTION_CONDITION: s << "contention_condition"; break;
  case AttrType::CURRENT_UNIT: s << "current_unit"; break;
  case AttrType::DATA_IN: s << "data_in"; break;
  case AttrType::DATE: s << "date"; break;
  case AttrType::DC_CURRENT_TEMPLATE: s << "dc_current_template"; break;
  case AttrType::DEFAULT_CELL_LEAKAGE_POWER: s << "default_cell_leakage_power"; break;
  case AttrType::DEFAULT_CONNECTION_CLASS: s << "default_connection_class"; break;
  case AttrType::DEFAULT_FALL_DELAY_INTERCEPT: s << "default_fall_delay_intercept"; break;
  case AttrType::DEFAULT_FALL_PIN_RESISTANCE: s << "default_fall_pin_resistance"; break;
  case AttrType::DEFAULT_FANOUT_LOAD: s << "default_fanout_load"; break;
  case AttrType::DEFAULT_INOUT_PIN_CAP: s << "default_inout_pin_cap"; break;
  case AttrType::DEFAULT_INOUT_PIN_FALL_RES: s << "default_inout_pin_fall_res"; break;
  case AttrType::DEFAULT_INOUT_PIN_RISE_RES: s << "default_inout_pin_rise_res"; break;
  case AttrType::DEFAULT_INPUT_PIN_CAP: s << "default_input_pin_cap"; break;
  case AttrType::DEFAULT_INTRINSIC_FALL: s << "default_intrinsic_fall"; break;
  case AttrType::DEFAULT_INTRINSIC_RISE: s << "default_intrinsic_rise"; break;
  case AttrType::DEFAULT_LEAKAGE_POWER_DENSITY: s << "default_leakage_power_density"; break;
  case AttrType::DEFAULT_MAX_CAPACITANCE: s << "default_max_capacitance"; break;
  case AttrType::DEFAULT_MAX_FANOUT: s << "default_max_fanout"; break;
  case AttrType::DEFAULT_MAX_TRANSITION: s << "default_max_transition"; break;
  case AttrType::DEFAULT_MAX_UTILIZATION: s << "default_max_utilization"; break;
  case AttrType::DEFAULT_MIN_POROSITY: s << "default_min_porosity"; break;
  case AttrType::DEFAULT_OPERATING_CONDITIONS: s << "default_operating_conditions"; break;
  case AttrType::DEFAULT_OUTPUT_PIN_CAP: s << "default_output_pin_cap"; break;
  case AttrType::DEFAULT_OUTPUT_PIN_FALL_RES: s << "default_output_pin_fall_res"; break;
  case AttrType::DEFAULT_OUTPUT_PIN_RISE_RES: s << "default_output_pin_rise_res"; break;
  case AttrType::DEFAULT_PART: s << "default_part"; break;
  case AttrType::DEFAULT_RISE_DELAY_INTERCEPT: s << "default_rise_delay_intercept"; break;
  case AttrType::DEFAULT_RISE_PIN_RESISTANCE: s << "default_rise_pin_resistance"; break;
  case AttrType::DEFAULT_SLOPE_FALL: s << "default_slope_fall"; break;
  case AttrType::DEFAULT_SLOPE_RISE: s << "default_slope_rise"; break;
  case AttrType::DEFAULT_WIRE_LOAD_AREA: s << "default_wire_load_area"; break;
  case AttrType::DEFAULT_WIRE_LOAD_CAPACITANCE: s << "default_wire_load_capacitance"; break;
  case AttrType::DEFAULT_WIRE_LOAD_MODE: s << "default_wire_load_mode"; break;
  case AttrType::DEFAULT_WIRE_LOAD_RESISTANCE: s << "default_wire_load_resistance"; break;
  case AttrType::DEFAULT_WIRE_LOAD_SELECTION: s << "default_wire_load_selection"; break;
  case AttrType::DEFAULT_WIRE_LOAD: s << "default_wire_load"; break;
  case AttrType::DEFINE_CELL_AREA: s << "define_cell_area"; break;
  case AttrType::DEFINE_GROUP: s << "define_group"; break;
  case AttrType::DEFINE: s << "define"; break;
  case AttrType::DELAY_MODEL: s << "delay_model"; break;
  case AttrType::DIRECTION: s << "direction"; break;
  case AttrType::DOMAIN: s << "domain"; break;
  case AttrType::DONT_FAULT: s << "dont_fault"; break;
  case AttrType::DONT_TOUCH: s << "dont_touch"; break;
  case AttrType::DONT_USE: s << "dont_use"; break;
  case AttrType::DRIVE_CURRENT: s << "drive_current"; break;
  case AttrType::DRIVER_TYPE: s << "driver_type"; break;
  case AttrType::DYNAMIC_CURRENT: s << "dynamic_current"; break;
  case AttrType::EDGE_RATE_SENSITIVITY_F0: s << "edge_rate_sensitivity_f0"; break;
  case AttrType::EDGE_RATE_SENSITIVITY_F1: s << "edge_rate_sensitivity_f1"; break;
  case AttrType::EDGE_RATE_SENSITIVITY_R0: s << "edge_rate_sensitivity_r0"; break;
  case AttrType::EDGE_RATE_SENSITIVITY_R1: s << "edge_rate_sensitivity_r1"; break;
  case AttrType::EDIF_NAME: s << "edif_name"; break;
  case AttrType::ELECTROMIGRATION: s << "electromigration"; break;
  case AttrType::EM_LUT_TEMPLATE: s << "em_lut_template"; break;
  case AttrType::EM_TEMP_DEGRADATION_FACTOR: s << "em_temp_degradation_factor"; break;
  case AttrType::ENABLE_ALSO: s << "enable_also"; break;
  case AttrType::ENABLE: s << "enable"; break;
  case AttrType::EQUAL_OR_OPPOSITE_OUTPUT: s << "equal_or_opposite_output"; break;
  case AttrType::FALL_CAPACITANCE_RANGE: s << "fall_capacitance_range"; break;
  case AttrType::FALL_CAPACITANCE: s << "fall_capacitance"; break;
  case AttrType::FALL_CONSTRAINT: s << "fall_constraint"; break;
  case AttrType::FALL_CURRENT_SLOPE_AFTER_THRESHOLD: s << "fall_current_slope_after_threshold"; break;
  case AttrType::FALL_CURRENT_SLOPE_BEFORE_THRESHOLD: s << "fall_current_slope_before_threshold"; break;
  case AttrType::FALL_DELAY_INTERCEPT: s << "fall_delay_intercept"; break;
  case AttrType::FALL_PIN_RESISTANCE: s << "fall_pin_resistance"; break;
  case AttrType::FALL_POWER: s << "fall_power"; break;
  case AttrType::FALL_PROPAGATION: s << "fall_propagation"; break;
  case AttrType::FALL_RESISTANCE: s << "fall_resistance"; break;
  case AttrType::FALL_TIME_AFTER_THRESHOLD: s << "fall_time_after_threshold"; break;
  case AttrType::FALL_TIME_BEFORE_THRESHOLD: s << "fall_time_before_threshold"; break;
  case AttrType::FALL_TRANSITION_DEGRADATION: s << "fall_transition_degradation"; break;
  case AttrType::FALL_TRANSITION: s << "fall_transition"; break;
  case AttrType::FALLING_TOGETHER_GROUP: s << "falling_together_group"; break;
  case AttrType::FANOUT_AREA: s << "fanout_area"; break;
  case AttrType::FANOUT_CAPACITANCE: s << "fanout_capacitance"; break;
  case AttrType::FANOUT_LENGTH: s << "fanout_length"; break;
  case AttrType::FANOUT_LOAD: s << "fanout_load"; break;
  case AttrType::FANOUT_RESISTANCE: s << "fanout_resistance"; break;
  case AttrType::FAULT_MODEL: s << "fault_model"; break;
  case AttrType::FAULTS_LUT_TEMPLATE: s << "faults_lut_template"; break;
  case AttrType::FF_BANK: s << "ff_bank"; break;
  case AttrType::FF: s << "ff"; break;
  case AttrType::FPGA_DOMAIN_STYLE: s << "fpga_domain_style"; break;
  case AttrType::FPGA_TECHNOLOGY: s << "fpga_technology"; break;
  case AttrType::FUNCTION: s << "function"; break;
  case AttrType::FUNCTIONAL_YIELD_METRIC: s << "functional_yield_metric"; break;
  case AttrType::GENERATED_CLOCK: s << "generated_clock"; break;
  case AttrType::GEOMETRY_PRINT: s << "geometry_print"; break;
  case AttrType::HANDLE_NEGATIVE_CONSTRAINT: s << "handle_negative_constraint"; break;
  case AttrType::HAS_BUILTIN_PAD: s << "has_builtin_pad"; break;
  case AttrType::HYPERBOLIC_NOISE_ABOVE_HIGH: s << "hyperbolic_noise_above_high"; break;
  case AttrType::HYPERBOLIC_NOISE_BELOW_LOW: s << "hyperbolic_noise_below_low"; break;
  case AttrType::HYPERBOLIC_NOISE_HIGH: s << "hyperbolic_noise_high"; break;
  case AttrType::HYPERBOLIC_NOISE_LOW: s << "hyperbolic_noise_low"; break;
  case AttrType::HYSTERESIS: s << "hysteresis"; break;
  case AttrType::IN_PLACE_SWAP_MODE: s << "in_place_swap_mode"; break;
  case AttrType::INDEX_1: s << "index_1"; break;
  case AttrType::INDEX_2: s << "index_2"; break;
  case AttrType::INDEX_3: s << "index_3"; break;
  case AttrType::INPUT_MAP: s << "input_map"; break;
  case AttrType::INPUT_SIGNAL_LEVEL: s << "input_signal_level"; break;
  case AttrType::INPUT_THRESHOLD_PCT_FALL: s << "input_threshold_pct_fall"; break;
  case AttrType::INPUT_THRESHOLD_PCT_RISE: s << "input_threshold_pct_rise"; break;
  case AttrType::INPUT_VOLTAGE: s << "input_voltage"; break;
  case AttrType::INTERFACE_TIMING: s << "interface_timing"; break;
  case AttrType::INTERNAL_NODE: s << "internal_node"; break;
  case AttrType::INTERNAL_POWER: s << "internal_power"; break;
  case AttrType::INTRINSIC_FALL: s << "intrinsic_fall"; break;
  case AttrType::INTRINSIC_PARASITIC: s << "intrinsic_parasitic"; break;
  case AttrType::INTRINSIC_RISE: s << "intrinsic_rise"; break;
  case AttrType::INVERTED_OUTPUT: s << "inverted_output"; break;
  case AttrType::IO_TYPE: s << "io_type"; break;
  case AttrType::IS_CLOCK_GATING_CELL: s << "is_clock_gating_cell"; break;
  case AttrType::IS_FILLER_CELL: s << "is_filler_cell"; break;
  case AttrType::IS_PAD: s << "is_pad"; break;
  case AttrType::IV_LUT_TEMPLATE: s << "iv_lut_template"; break;
  case AttrType::K_PROCESS_CELL_FALL: s << "k_process_cell_fall"; break;
  case AttrType::K_PROCESS_CELL_LEAKAGE_POWER: s << "k_process_cell_leakage_power"; break;
  case AttrType::K_PROCESS_CELL_RISE: s << "k_process_cell_rise"; break;
  case AttrType::K_PROCESS_DRIVE_CURRENT: s << "k_process_drive_current"; break;
  case AttrType::K_PROCESS_DRIVE_FALL: s << "k_process_drive_fall"; break;
  case AttrType::K_PROCESS_DRIVE_RISE: s << "k_process_drive_rise"; break;
  case AttrType::K_PROCESS_FALL_DELAY_INTERCEPT: s << "k_process_fall_delay_intercept"; break;
  case AttrType::K_PROCESS_FALL_PIN_RESISTANCE: s << "k_process_fall_pin_resistance"; break;
  case AttrType::K_PROCESS_FALL_PROPAGATION: s << "k_process_fall_propagation"; break;
  case AttrType::K_PROCESS_FALL_TRANSITION: s << "k_process_fall_transition"; break;
  case AttrType::K_PROCESS_HOLD_FALL: s << "k_process_hold_fall"; break;
  case AttrType::K_PROCESS_HOLD_RISE: s << "k_process_hold_rise"; break;
  case AttrType::K_PROCESS_INTERNAL_POWER: s << "k_process_internal_power"; break;
  case AttrType::K_PROCESS_INTRINSIC_FALL: s << "k_process_intrinsic_fall"; break;
  case AttrType::K_PROCESS_INTRINSIC_RISE: s << "k_process_intrinsic_rise"; break;
  case AttrType::K_PROCESS_MIN_PERIOD: s << "k_process_min_period"; break;
  case AttrType::K_PROCESS_MIN_PULSE_WIDTH_HIGH: s << "k_process_min_pulse_width_high"; break;
  case AttrType::K_PROCESS_MIN_PULSE_WIDTH_LOW: s << "k_process_min_pulse_width_low"; break;
  case AttrType::K_PROCESS_NOCHANGE_FALL: s << "k_process_nochange_fall"; break;
  case AttrType::K_PROCESS_NOCHANGE_RISE: s << "k_process_nochange_rise"; break;
  case AttrType::K_PROCESS_PIN_CAP: s << "k_process_pin_cap"; break;
  case AttrType::K_PROCESS_RECOVERY_FALL: s << "k_process_recovery_fall"; break;
  case AttrType::K_PROCESS_RECOVERY_RISE: s << "k_process_recovery_rise"; break;
  case AttrType::K_PROCESS_REMOVAL_FALL: s << "k_process_removal_fall"; break;
  case AttrType::K_PROCESS_REMOVAL_RISE: s << "k_process_removal_rise"; break;
  case AttrType::K_PROCESS_RISE_TRANSITION: s << "k_process_rise_transition"; break;
  case AttrType::K_PROCESS_RISE_DELAY_INTERCEPT: s << "k_process_rise_delay_intercept"; break;
  case AttrType::K_PROCESS_RISE_PIN_RESISTANCE: s << "k_process_rise_pin_resistance"; break;
  case AttrType::K_PROCESS_RISE_PROPAGATION: s << "k_process_rise_propagation"; break;
  case AttrType::K_PROCESS_SETUP_FALL: s << "k_process_setup_fall"; break;
  case AttrType::K_PROCESS_SETUP_RISE: s << "k_process_setup_rise"; break;
  case AttrType::K_PROCESS_SKEW_FALL: s << "k_process_skew_fall"; break;
  case AttrType::K_PROCESS_SKEW_RISE: s << "k_process_skew_rise"; break;
  case AttrType::K_PROCESS_SLOPE_FALL: s << "k_process_slope_fall"; break;
  case AttrType::K_PROCESS_SLOPE_RISE: s << "k_process_slope_rise"; break;
  case AttrType::K_PROCESS_WIRE_CAP: s << "k_process_wire_cap"; break;
  case AttrType::K_PROCESS_WIRE_RES: s << "k_process_wire_res"; break;
  case AttrType::K_TEMP_CELL_FALL: s << "k_temp_cell_fall"; break;
  case AttrType::K_TEMP_CELL_LEAKAGE_POWER: s << "k_temp_cell_leakage_power"; break;
  case AttrType::K_TEMP_CELL_RISE: s << "k_temp_cell_rise"; break;
  case AttrType::K_TEMP_DRIVE_CURRENT: s << "k_temp_drive_current"; break;
  case AttrType::K_TEMP_DRIVE_FALL: s << "k_temp_drive_fall"; break;
  case AttrType::K_TEMP_DRIVE_RISE: s << "k_temp_drive_rise"; break;
  case AttrType::K_TEMP_FALL_DELAY_INTERCEPT: s << "k_temp_fall_delay_intercept"; break;
  case AttrType::K_TEMP_FALL_PIN_RESISTANCE: s << "k_temp_fall_pin_resistance"; break;
  case AttrType::K_TEMP_FALL_PROPAGATION: s << "k_temp_fall_propagation"; break;
  case AttrType::K_TEMP_FALL_TRANSITION: s << "k_temp_fall_transition"; break;
  case AttrType::K_TEMP_HOLD_FALL: s << "k_temp_hold_fall"; break;
  case AttrType::K_TEMP_HOLD_RISE: s << "k_temp_hold_rise"; break;
  case AttrType::K_TEMP_INTERNAL_POWER: s << "k_temp_internal_power"; break;
  case AttrType::K_TEMP_INTRINSIC_FALL: s << "k_temp_intrinsic_fall"; break;
  case AttrType::K_TEMP_INTRINSIC_RISE: s << "k_temp_intrinsic_rise"; break;
  case AttrType::K_TEMP_MIN_PERIOD: s << "k_temp_min_period"; break;
  case AttrType::K_TEMP_MIN_PULSE_WIDTH_HIGH: s << "k_temp_min_pulse_width_high"; break;
  case AttrType::K_TEMP_MIN_PULSE_WIDTH_LOW: s << "k_temp_min_pulse_width_low"; break;
  case AttrType::K_TEMP_NOCHANGE_FALL: s << "k_temp_nochange_fall"; break;
  case AttrType::K_TEMP_NOCHANGE_RISE: s << "k_temp_nochange_rise"; break;
  case AttrType::K_TEMP_PIN_CAP: s << "k_temp_pin_cap"; break;
  case AttrType::K_TEMP_RECOVERY_FALL: s << "k_temp_recovery_fall"; break;
  case AttrType::K_TEMP_RECOVERY_RISE: s << "k_temp_recovery_rise"; break;
  case AttrType::K_TEMP_REMOVAL_FALL: s << "k_temp_removal_fall"; break;
  case AttrType::K_TEMP_REMOVAL_RISE: s << "k_temp_removal_rise"; break;
  case AttrType::K_TEMP_RISE_TRANSITION: s << "k_temp_rise_transition"; break;
  case AttrType::K_TEMP_RISE_DELAY_INTERCEPT: s << "k_temp_rise_delay_intercept"; break;
  case AttrType::K_TEMP_RISE_PIN_RESISTANCE: s << "k_temp_rise_pin_resistance"; break;
  case AttrType::K_TEMP_RISE_PROPAGATION: s << "k_temp_rise_propagation"; break;
  case AttrType::K_TEMP_SETUP_FALL: s << "k_temp_setup_fall"; break;
  case AttrType::K_TEMP_SETUP_RISE: s << "k_temp_setup_rise"; break;
  case AttrType::K_TEMP_SKEW_FALL: s << "k_temp_skew_fall"; break;
  case AttrType::K_TEMP_SKEW_RISE: s << "k_temp_skew_rise"; break;
  case AttrType::K_TEMP_SLOPE_FALL: s << "k_temp_slope_fall"; break;
  case AttrType::K_TEMP_SLOPE_RISE: s << "k_temp_slope_rise"; break;
  case AttrType::K_TEMP_WIRE_CAP: s << "k_temp_wire_cap"; break;
  case AttrType::K_TEMP_WIRE_RES: s << "k_temp_wire_res"; break;
  case AttrType::K_VOLT_CELL_FALL: s << "k_volt_cell_fall"; break;
  case AttrType::K_VOLT_CELL_LEAKAGE_POWER: s << "k_volt_cell_leakage_power"; break;
  case AttrType::K_VOLT_CELL_RISE: s << "k_volt_cell_rise"; break;
  case AttrType::K_VOLT_DRIVE_CURRENT: s << "k_volt_drive_current"; break;
  case AttrType::K_VOLT_DRIVE_FALL: s << "k_volt_drive_fall"; break;
  case AttrType::K_VOLT_DRIVE_RISE: s << "k_volt_drive_rise"; break;
  case AttrType::K_VOLT_FALL_DELAY_INTERCEPT: s << "k_volt_fall_delay_intercept"; break;
  case AttrType::K_VOLT_FALL_PIN_RESISTANCE: s << "k_volt_fall_pin_resistance"; break;
  case AttrType::K_VOLT_FALL_PROPAGATION: s << "k_volt_fall_propagation"; break;
  case AttrType::K_VOLT_FALL_TRANSITION: s << "k_volt_fall_transition"; break;
  case AttrType::K_VOLT_HOLD_FALL: s << "k_volt_hold_fall"; break;
  case AttrType::K_VOLT_HOLD_RISE: s << "k_volt_hold_rise"; break;
  case AttrType::K_VOLT_INTERNAL_POWER: s << "k_volt_internal_power"; break;
  case AttrType::K_VOLT_INTRINSIC_FALL: s << "k_volt_intrinsic_fall"; break;
  case AttrType::K_VOLT_INTRINSIC_RISE: s << "k_volt_intrinsic_rise"; break;
  case AttrType::K_VOLT_MIN_PERIOD: s << "k_volt_min_period"; break;
  case AttrType::K_VOLT_MIN_PULSE_WIDTH_HIGH: s << "k_volt_min_pulse_width_high"; break;
  case AttrType::K_VOLT_MIN_PULSE_WIDTH_LOW: s << "k_volt_min_pulse_width_low"; break;
  case AttrType::K_VOLT_NOCHANGE_FALL: s << "k_volt_nochange_fall"; break;
  case AttrType::K_VOLT_NOCHANGE_RISE: s << "k_volt_nochange_rise"; break;
  case AttrType::K_VOLT_PIN_CAP: s << "k_volt_pin_cap"; break;
  case AttrType::K_VOLT_RECOVERY_FALL: s << "k_volt_recovery_fall"; break;
  case AttrType::K_VOLT_RECOVERY_RISE: s << "k_volt_recovery_rise"; break;
  case AttrType::K_VOLT_REMOVAL_FALL: s << "k_volt_removal_fall"; break;
  case AttrType::K_VOLT_REMOVAL_RISE: s << "k_volt_removal_rise"; break;
  case AttrType::K_VOLT_RISE_TRANSITION: s << "k_volt_rise_transition"; break;
  case AttrType::K_VOLT_RISE_DELAY_INTERCEPT: s << "k_volt_rise_delay_intercept"; break;
  case AttrType::K_VOLT_RISE_PIN_RESISTANCE: s << "k_volt_rise_pin_resistance"; break;
  case AttrType::K_VOLT_RISE_PROPAGATION: s << "k_volt_rise_propagation"; break;
  case AttrType::K_VOLT_SETUP_FALL: s << "k_volt_setup_fall"; break;
  case AttrType::K_VOLT_SETUP_RISE: s << "k_volt_setup_rise"; break;
  case AttrType::K_VOLT_SKEW_FALL: s << "k_volt_skew_fall"; break;
  case AttrType::K_VOLT_SKEW_RISE: s << "k_volt_skew_rise"; break;
  case AttrType::K_VOLT_SLOPE_FALL: s << "k_volt_slope_fall"; break;
  case AttrType::K_VOLT_SLOPE_RISE: s << "k_volt_slope_rise"; break;
  case AttrType::K_VOLT_WIRE_CAP: s << "k_volt_wire_cap"; break;
  case AttrType::K_VOLT_WIRE_RES: s << "k_volt_wire_res"; break;
  case AttrType::LATCH_BANK: s << "latch_bank"; break;
  case AttrType::LATCH: s << "latch"; break;
  case AttrType::LEAKAGE_CURRENT: s << "leakage_current"; break;
  case AttrType::LEAKAGE_POWER_UNIT: s << "leakage_power_unit"; break;
  case AttrType::LEAKAGE_POWER: s << "leakage_power"; break;
  case AttrType::LIBRARY_FEATURES: s << "library_features"; break;
  case AttrType::LIBRARY: s << "library"; break;
  case AttrType::LU_TABLE_TEMPLATE: s << "lu_table_template"; break;
  case AttrType::LUT: s << "lut"; break;
  case AttrType::MAP_ONLY: s << "map_only"; break;
  case AttrType::MAX_CAPACITANCE: s << "max_capacitance"; break;
  case AttrType::MAX_FANOUT: s << "max_fanout"; break;
  case AttrType::MAX_INPUT_NOISE_WIDTH: s << "max_input_noise_width"; break;
  case AttrType::MAX_TRANS: s << "max_trans"; break;
  case AttrType::MAX_TRANSITION: s << "max_transition"; break;
  case AttrType::MEMBERS: s << "members"; break;
  case AttrType::MIN_CAPACITANCE: s << "min_capacitance"; break;
  case AttrType::MIN_FANOUT: s << "min_fanout"; break;
  case AttrType::MIN_INPUT_NOISE_WIDTH: s << "min_input_noise_width"; break;
  case AttrType::MIN_PERIOD: s << "min_period"; break;
  case AttrType::MIN_PULSE_WIDTH_HIGH: s << "min_pulse_width_high"; break;
  case AttrType::MIN_PULSE_WIDTH_LOW: s << "min_pulse_width_low"; break;
  case AttrType::MIN_PULSE_WIDTH: s << "min_pulse_width"; break;
  case AttrType::MIN_TRANSITION: s << "min_transition"; break;
  case AttrType::MINIMUM_PERIOD: s << "minimum_period"; break;
  case AttrType::MODE_DEFINITION: s << "mode_definition"; break;
  case AttrType::MULTICELL_PAD_PIN: s << "multicell_pad_pin"; break;
  case AttrType::NEXT_STATE: s << "next_state"; break;
  case AttrType::NEXTSTATE_TYPE: s << "nextstate_type"; break;
  case AttrType::NOISE_IMMUNITY_ABOVE_HIGH: s << "noise_immunity_above_high"; break;
  case AttrType::NOISE_IMMUNITY_BELOW_LOW: s << "noise_immunity_below_low"; break;
  case AttrType::NOISE_IMMUNITY_HIGH: s << "noise_immunity_high"; break;
  case AttrType::NOISE_IMMUNITY_LOW: s << "noise_immunity_low"; break;
  case AttrType::NOISE_LUT_TEMPLATE: s << "noise_lut_template"; break;
  case AttrType::NOM_CALC_MODE: s << "nom_calc_mode"; break;
  case AttrType::NOM_PROCESS: s << "nom_process"; break;
  case AttrType::NOM_TEMPERATURE: s << "nom_temperature"; break;
  case AttrType::NOM_VOLTAGE: s << "nom_voltage"; break;
  case AttrType::OPERATING_CONDITIONS: s << "operating_conditions"; break;
  case AttrType::ORDERS: s << "orders"; break;
  case AttrType::OUTPUT_CURRENT_TEMPLATE: s << "output_current_template"; break;
  case AttrType::OUTPUT_SIGNAL_LEVEL: s << "output_signal_level"; break;
  case AttrType::OUTPUT_THRESHOLD_PCT_FALL: s << "output_threshold_pct_fall"; break;
  case AttrType::OUTPUT_THRESHOLD_PCT_RISE: s << "output_threshold_pct_rise"; break;
  case AttrType::OUTPUT_VOLTAGE: s << "output_voltage"; break;
  case AttrType::PAD_CELL: s << "pad_cell"; break;
  case AttrType::PAD_TYPE: s << "pad_type"; break;
  case AttrType::PARAMETER1: s << "parameter1"; break;
  case AttrType::PARAMETER2: s << "parameter2"; break;
  case AttrType::PARAMETER3: s << "parameter3"; break;
  case AttrType::PARAMETER4: s << "parameter4"; break;
  case AttrType::PARAMETER5: s << "parameter5"; break;
  case AttrType::PART: s << "part"; break;
  case AttrType::PIECE_DEFINE: s << "piece_define"; break;
  case AttrType::PIECE_TYPE: s << "piece_type"; break;
  case AttrType::PIN_FUNC_TYPE: s << "pin_func_type"; break;
  case AttrType::PIN_OPPOSITE: s << "pin_opposite"; break;
  case AttrType::PIN: s << "pin"; break;
  case AttrType::POLY_TEMPLATE: s << "poly_template"; break;
  case AttrType::POWER_CELL_TYPE: s << "power_cell_type"; break;
  case AttrType::POWER_LEVEL: s << "power_level"; break;
  case AttrType::POWER_LUT_TEMPLATE: s << "power_lut_template"; break;
  case AttrType::POWER_POLY_TEMPLATE: s << "power_poly_template"; break;
  case AttrType::POWER_MODEL: s << "power_model"; break;
  case AttrType::POWER_RAIL: s << "power_rail"; break;
  case AttrType::POWER_SUPPLY_NAMESTRING: s << "power_supply_namestring"; break;
  case AttrType::POWER_SUPPLY: s << "power_supply"; break;
  case AttrType::POWER: s << "power"; break;
  case AttrType::PREFER_TIED: s << "prefer_tied"; break;
  case AttrType::PREFERRED: s << "preferred"; break;
  case AttrType::PREFERRED_INPUT_PAD_VOLTAGE: s << "preferred_input_pad_voltage"; break;
  case AttrType::PREFERRED_OUTPUT_PAD_SLEW_RATE_CONTROL: s << "preferred_output_pad_slew_rate_control"; break;
  case AttrType::PREFERRED_OUTPUT_PAD_VOLTAGE: s << "preferred_output_pad_voltage"; break;
  case AttrType::PRESET: s << "preset"; break;
  case AttrType::PRIMARY_OUTPUT: s << "primary_output"; break;
  case AttrType::PROCESS: s << "process"; break;
  case AttrType::PROPAGATED_NOISE_HEIGHT_ABOVE_HIGH: s << "propagated_noise_height_above_high"; break;
  case AttrType::PROPAGATED_NOISE_HEIGHT_BELOW_LOW: s << "propagated_noise_height_below_low"; break;
  case AttrType::PROPAGATED_NOISE_HEIGHT_HIGH: s << "propagated_noise_height_high"; break;
  case AttrType::PROPAGATED_NOISE_HEIGHT_LOW: s << "propagated_noise_height_low"; break;
  case AttrType::PROPAGATED_NOISE_PEAK_TIME_RATIO_ABOVE_HIGH: s << "propagated_noise_peak_time_ratio_above_high"; break;
  case AttrType::PROPAGATED_NOISE_PEAK_TIME_RATIO_BELOW_LOW: s << "propagated_noise_peak_time_ratio_below_low"; break;
  case AttrType::PROPAGATED_NOISE_PEAK_TIME_RATIO_HIGH: s << "propagated_noise_peak_time_ratio_high"; break;
  case AttrType::PROPAGATED_NOISE_PEAK_TIME_RATIO_LOW: s << "propagated_noise_peak_time_ratio_low"; break;
  case AttrType::PROPAGATED_NOISE_WIDTH_ABOVE_HIGH: s << "propagated_noise_width_above_high"; break;
  case AttrType::PROPAGATED_NOISE_WIDTH_BELOW_LOW: s << "propagated_noise_width_below_low"; break;
  case AttrType::PROPAGATED_NOISE_WIDTH_HIGH: s << "propagated_noise_width_high"; break;
  case AttrType::PROPAGATED_NOISE_WIDTH_LOW: s << "propagated_noise_width_low"; break;
  case AttrType::PROPAGATION_LUT_TEMPLATE: s << "propagation_lut_template"; break;
  case AttrType::PULLING_CURRENT: s << "pulling_current"; break;
  case AttrType::PULLING_RESISTANCE_UNIT: s << "pulling_resistance_unit"; break;
  case AttrType::PULLING_RESISTANCE: s << "pulling_resistance"; break;
  case AttrType::RAIL_CONNECTION: s << "rail_connection"; break;
  case AttrType::RELATED_BUS_EQUIVALENT: s << "related_bus_equivalent"; break;
  case AttrType::RELATED_BUS_PINS: s << "related_bus_pins"; break;
  case AttrType::RELATED_INPUTS: s << "related_inputs"; break;
  case AttrType::RELATED_OUTPUT_PIN: s << "related_output_pin"; break;
  case AttrType::RELATED_OUTPUTS: s << "related_outputs"; break;
  case AttrType::RELATED_PG_PIN: s << "related_pg_pin"; break;
  case AttrType::RELATED_PIN: s << "related_pin"; break;
  case AttrType::RESISTANCE: s << "resistance"; break;
  case AttrType::RESOURCE_USAGE: s << "resource_usage"; break;
  case AttrType::RETAIN_FALL_SLEW: s << "retain_fall_slew"; break;
  case AttrType::RETAIN_RISE_SLEW: s << "retain_rise_slew"; break;
  case AttrType::RETAINING_FALL: s << "retaining_fall"; break;
  case AttrType::RETAINING_RISE: s << "retaining_rise"; break;
  case AttrType::REVISION: s << "revision"; break;
  case AttrType::RISE_CAPACITANCE_RANGE: s << "rise_capacitance_range"; break;
  case AttrType::RISE_CAPACITANCE: s << "rise_capacitance"; break;
  case AttrType::RISE_CONSTRAINT: s << "rise_constraint"; break;
  case AttrType::RISE_CURRENT_SLOPE_AFTER_THRESHOLD: s << "rise_current_slope_after_threshold"; break;
  case AttrType::RISE_CURRENT_SLOPE_BEFORE_THRESHOLD: s << "rise_current_slope_before_threshold"; break;
  case AttrType::RISE_DELAY_INTERCEPT: s << "rise_delay_intercept"; break;
  case AttrType::RISE_PIN_RESISTANCE: s << "rise_pin_resistance"; break;
  case AttrType::RISE_POWER: s << "rise_power"; break;
  case AttrType::RISE_PROPAGATION: s << "rise_propagation"; break;
  case AttrType::RISE_RESISTANCE: s << "rise_resistance"; break;
  case AttrType::RISE_TIME_AFTER_THRESHOLD: s << "rise_time_after_threshold"; break;
  case AttrType::RISE_TIME_BEFORE_THRESHOLD: s << "rise_time_before_threshold"; break;
  case AttrType::RISE_TRANSITION_DEGRADATION: s << "rise_transition_degradation"; break;
  case AttrType::RISE_TRANSITION: s << "rise_transition"; break;
  case AttrType::RISING_TOGETHER_GROUP: s << "rising_together_group"; break;
  case AttrType::ROUTING_LAYERS: s << "routing_layers"; break;
  case AttrType::ROUTING_TRACK: s << "routing_track"; break;
  case AttrType::SCALED_CELL: s << "scaled_cell"; break;
  case AttrType::SCALING_FACTORS: s << "scaling_factors"; break;
  case AttrType::SDF_COND_END: s << "sdf_cond_end"; break;
  case AttrType::SDF_COND_START: s << "sdf_cond_start"; break;
  case AttrType::SDF_COND: s << "sdf_cond"; break;
  case AttrType::SDF_EDGES: s << "sdf_edges"; break;
  case AttrType::SIGNAL_TYPE: s << "signal_type"; break;
  case AttrType::SIMULATION: s << "simulation"; break;
  case AttrType::SINGLE_BIT_DEGENERATE: s << "single_bit_degenerate"; break;
  case AttrType::SLEW_CONTROL: s << "slew_control"; break;
  case AttrType::SLEW_DERATE_FROM_LIBRARY: s << "slew_derate_from_library"; break;
  case AttrType::SLEW_LOWER_THRESHOLD_PCT_FALL: s << "slew_lower_threshold_pct_fall"; break;
  case AttrType::SLEW_LOWER_THRESHOLD_PCT_RISE: s << "slew_lower_threshold_pct_rise"; break;
  case AttrType::SLEW_TYPE: s << "slew_type"; break;
  case AttrType::SLEW_UPPER_THRESHOLD_PCT_FALL: s << "slew_upper_threshold_pct_fall"; break;
  case AttrType::SLEW_UPPER_THRESHOLD_PCT_RISE: s << "slew_upper_threshold_pct_rise"; break;
  case AttrType::SLOPE_FALL: s << "slope_fall"; break;
  case AttrType::SLOPE_RISE: s << "slope_rise"; break;
  case AttrType::SLOPE: s << "slope"; break;
  case AttrType::STATE_FUNCTION: s << "state_function"; break;
  case AttrType::STATETABLE: s << "statetable"; break;
  case AttrType::STEADY_STATE_CURRENT_HIGH: s << "steady_state_current_high"; break;
  case AttrType::STEADY_STATE_CURRENT_LOW: s << "steady_state_current_low"; break;
  case AttrType::STEADY_STATE_CURRENT_TRISTATE: s << "steady_state_current_tristate"; break;
  case AttrType::SWITCHING_INTERVAL: s << "switching_interval"; break;
  case AttrType::SWITCHING_TOGETHER_GROUP: s << "switching_together_group"; break;
  case AttrType::TABLE: s << "table"; break;
  case AttrType::TECHNOLOGY: s << "technology"; break;
  case AttrType::TEMPERATURE: s << "temperature"; break;
  case AttrType::TEST_CELL: s << "test_cell"; break;
  case AttrType::TEST_OUTPUT_ONLY: s << "test_output_only"; break;
  case AttrType::THREE_STATE: s << "three_state"; break;
  case AttrType::TIME_UNIT: s << "time_unit"; break;
  case AttrType::TIMING_MODEL_TYPE: s << "timing_model_type"; break;
  case AttrType::TIMING_RANGE: s << "timing_range"; break;
  case AttrType::TIMING_SENSE: s << "timing_sense"; break;
  case AttrType::TIMING_TYPE: s << "timing_type"; break;
  case AttrType::TIMING: s << "timing"; break;
  case AttrType::TLATCH: s << "tlatch"; break;
  case AttrType::TREE_TYPE: s << "tree_type"; break;
  case AttrType::TYPE: s << "type"; break;
  case AttrType::USE_FOR_SIZE_ONLY: s << "use_for_size_only"; break;
  case AttrType::VALUE: s << "value"; break;
  case AttrType::VALUES: s << "values"; break;
  case AttrType::VARIABLE_1: s << "variable_1"; break;
  case AttrType::VARIABLE_2: s << "variable_2"; break;
  case AttrType::VARIABLE_3: s << "variable_3"; break;
  case AttrType::VHDL_NAME: s << "vhdl_name"; break;
  case AttrType::VIH: s << "vih"; break;
  case AttrType::VIL: s << "vil"; break;
  case AttrType::VIMAX: s << "vimax"; break;
  case AttrType::VIMIN: s << "vimin"; break;
  case AttrType::VOH: s << "voh"; break;
  case AttrType::VOL: s << "vol"; break;
  case AttrType::VOLTAGE_UNIT: s << "voltage_unit"; break;
  case AttrType::VOLTAGE: s << "voltage"; break;
  case AttrType::VOMAX: s << "vomax"; break;
  case AttrType::VOMIN: s << "vomin"; break;
  case AttrType::WHEN_END: s << "when_end"; break;
  case AttrType::WHEN_START: s << "when_start"; break;
  case AttrType::WHEN: s << "when"; break;
  case AttrType::WIRE_LOAD_FROM_AREA: s << "wire_load_from_area"; break;
  case AttrType::WIRE_LOAD_SELECTION: s << "wire_load_selection"; break;
  case AttrType::WIRE_LOAD_TABLE: s << "wire_load_table"; break;
  case AttrType::WIRE_LOAD: s << "wire_load"; break;
  case AttrType::X_FUNCTION: s << "x_function"; break;
  case AttrType::END: s << "---"; break;
  }
  return s;
}

END_NAMESPACE_YM_DOTLIB
