
/// @file AttrDic.cc
/// @brief AttrDic の実装ファイル
/// @author Yusuke Matsunaga (松永 裕介)
///
/// Copyright (C) 2018 Yusuke Matsunaga
/// All rights reserved.


#include "AttrDic.h"


BEGIN_NAMESPACE_YM_DOTLIB

//////////////////////////////////////////////////////////////////////
// クラス AttrDic
//////////////////////////////////////////////////////////////////////

// @brief コンストラクタ
AttrDic::AttrDic()
{
  // gen_attr_dic.py で作成
  mDic.add("area", ATTR_AREA);
  mDic.add("auxiliary_pad_cell", ATTR_AUXILIARY_PAD_CELL);
  mDic.add("base_name", ATTR_BASE_NAME);
  mDic.add("bit_width", ATTR_BIT_WIDTH);
  mDic.add("bundle", ATTR_BUNDLE);
  mDic.add("bus_naming_style", ATTR_BUS_NAMING_STYLE);
  mDic.add("bus_type", ATTR_BUS_TYPE);
  mDic.add("bus", ATTR_BUS);
  mDic.add("calc_mode", ATTR_CALC_MODE);
  mDic.add("capacitance", ATTR_CAPACITANCE);
  mDic.add("capacitive_load_unit", ATTR_CAPACITIVE_LOAD_UNIT);
  mDic.add("cell_degradation", ATTR_CELL_DEGRADATION);
  mDic.add("cell_fall", ATTR_CELL_FALL);
  mDic.add("cell_footprint", ATTR_CELL_FOOTPRINT);
  mDic.add("cell_leakage_power", ATTR_CELL_LEAKAGE_POWER);
  mDic.add("cell_rise", ATTR_CELL_RISE);
  mDic.add("cell", ATTR_CELL);
  mDic.add("clear_preset_var1", ATTR_CLEAR_PRESET_VAR1);
  mDic.add("clear_preset_var2", ATTR_CLEAR_PRESET_VAR2);
  mDic.add("clear", ATTR_CLEAR);
  mDic.add("clock_gate_clock_pin", ATTR_CLOCK_GATE_CLOCK_PIN);
  mDic.add("clock_gate_enable_pin", ATTR_CLOCK_GATE_ENABLE_PIN);
  mDic.add("clock_gate_test_pin", ATTR_CLOCK_GATE_TEST_PIN);
  mDic.add("clock_gate_obs_pin", ATTR_CLOCK_GATE_OBS_PIN);
  mDic.add("clock_gate_out_pin", ATTR_CLOCK_GATE_OUT_PIN);
  mDic.add("clock_gating_integrated_cell", ATTR_CLOCK_GATING_INTEGRATED_CELL);
  mDic.add("clock", ATTR_CLOCK);
  mDic.add("clocked_on_also", ATTR_CLOCKED_ON_ALSO);
  mDic.add("clocked_on", ATTR_CLOCKED_ON);
  mDic.add("coefs", ATTR_COEFS);
  mDic.add("comment", ATTR_COMMENT);
  mDic.add("complementary_pin", ATTR_COMPLEMENTARY_PIN);
  mDic.add("connection_class", ATTR_CONNECTION_CLASS);
  mDic.add("contention_condition", ATTR_CONTENTION_CONDITION);
  mDic.add("current_unit", ATTR_CURRENT_UNIT);
  mDic.add("data_in", ATTR_DATA_IN);
  mDic.add("date", ATTR_DATE);
  mDic.add("dc_current_template", ATTR_DC_CURRENT_TEMPLATE);
  mDic.add("default_cell_leakage_power", ATTR_DEFAULT_CELL_LEAKAGE_POWER);
  mDic.add("default_connection_class", ATTR_DEFAULT_CONNECTION_CLASS);
  mDic.add("default_fall_delay_intercept", ATTR_DEFAULT_FALL_DELAY_INTERCEPT);
  mDic.add("default_fall_pin_resistance", ATTR_DEFAULT_FALL_PIN_RESISTANCE);
  mDic.add("default_fanout_load", ATTR_DEFAULT_FANOUT_LOAD);
  mDic.add("default_inout_pin_cap", ATTR_DEFAULT_INOUT_PIN_CAP);
  mDic.add("default_inout_pin_fall_res", ATTR_DEFAULT_INOUT_PIN_FALL_RES);
  mDic.add("default_inout_pin_rise_res", ATTR_DEFAULT_INOUT_PIN_RISE_RES);
  mDic.add("default_input_pin_cap", ATTR_DEFAULT_INPUT_PIN_CAP);
  mDic.add("default_intrinsic_fall", ATTR_DEFAULT_INTRINSIC_FALL);
  mDic.add("default_intrinsic_rise", ATTR_DEFAULT_INTRINSIC_RISE);
  mDic.add("default_leakage_power_density", ATTR_DEFAULT_LEAKAGE_POWER_DENSITY);
  mDic.add("default_max_capacitance", ATTR_DEFAULT_MAX_CAPACITANCE);
  mDic.add("default_max_fanout", ATTR_DEFAULT_MAX_FANOUT);
  mDic.add("default_max_transition", ATTR_DEFAULT_MAX_TRANSITION);
  mDic.add("default_max_utilization", ATTR_DEFAULT_MAX_UTILIZATION);
  mDic.add("default_min_porosity", ATTR_DEFAULT_MIN_POROSITY);
  mDic.add("default_operating_conditions", ATTR_DEFAULT_OPERATING_CONDITIONS);
  mDic.add("default_output_pin_cap", ATTR_DEFAULT_OUTPUT_PIN_CAP);
  mDic.add("default_output_pin_fall_res", ATTR_DEFAULT_OUTPUT_PIN_FALL_RES);
  mDic.add("default_output_pin_rise_res", ATTR_DEFAULT_OUTPUT_PIN_RISE_RES);
  mDic.add("default_part", ATTR_DEFAULT_PART);
  mDic.add("default_rise_delay_intercept", ATTR_DEFAULT_RISE_DELAY_INTERCEPT);
  mDic.add("default_rise_pin_resistance", ATTR_DEFAULT_RISE_PIN_RESISTANCE);
  mDic.add("default_slope_fall", ATTR_DEFAULT_SLOPE_FALL);
  mDic.add("default_slope_rise", ATTR_DEFAULT_SLOPE_RISE);
  mDic.add("default_wire_load_area", ATTR_DEFAULT_WIRE_LOAD_AREA);
  mDic.add("default_wire_load_capacitance", ATTR_DEFAULT_WIRE_LOAD_CAPACITANCE);
  mDic.add("default_wire_load_mode", ATTR_DEFAULT_WIRE_LOAD_MODE);
  mDic.add("default_wire_load_resistance", ATTR_DEFAULT_WIRE_LOAD_RESISTANCE);
  mDic.add("default_wire_load_selection", ATTR_DEFAULT_WIRE_LOAD_SELECTION);
  mDic.add("default_wire_load", ATTR_DEFAULT_WIRE_LOAD);
  mDic.add("define_cell_area", ATTR_DEFINE_CELL_AREA);
  mDic.add("define_group", ATTR_DEFINE_GROUP);
  mDic.add("define", ATTR_DEFINE);
  mDic.add("delay_model", ATTR_DELAY_MODEL);
  mDic.add("direction", ATTR_DIRECTION);
  mDic.add("domain", ATTR_DOMAIN);
  mDic.add("dont_fault", ATTR_DONT_FAULT);
  mDic.add("dont_touch", ATTR_DONT_TOUCH);
  mDic.add("dont_use", ATTR_DONT_USE);
  mDic.add("drive_current", ATTR_DRIVE_CURRENT);
  mDic.add("driver_type", ATTR_DRIVER_TYPE);
  mDic.add("dynamic_current", ATTR_DYNAMIC_CURRENT);
  mDic.add("edge_rate_sensitivity_f0", ATTR_EDGE_RATE_SENSITIVITY_F0);
  mDic.add("edge_rate_sensitivity_f1", ATTR_EDGE_RATE_SENSITIVITY_F1);
  mDic.add("edge_rate_sensitivity_r0", ATTR_EDGE_RATE_SENSITIVITY_R0);
  mDic.add("edge_rate_sensitivity_r1", ATTR_EDGE_RATE_SENSITIVITY_R1);
  mDic.add("edif_name", ATTR_EDIF_NAME);
  mDic.add("electromigration", ATTR_ELECTROMIGRATION);
  mDic.add("em_lut_template", ATTR_EM_LUT_TEMPLATE);
  mDic.add("em_temp_degradation_factor", ATTR_EM_TEMP_DEGRADATION_FACTOR);
  mDic.add("enable_also", ATTR_ENABLE_ALSO);
  mDic.add("enable", ATTR_ENABLE);
  mDic.add("equal_or_opposite_output", ATTR_EQUAL_OR_OPPOSITE_OUTPUT);
  mDic.add("fall_capacitance_range", ATTR_FALL_CAPACITANCE_RANGE);
  mDic.add("fall_capacitance", ATTR_FALL_CAPACITANCE);
  mDic.add("fall_constraint", ATTR_FALL_CONSTRAINT);
  mDic.add("fall_current_slope_after_threshold", ATTR_FALL_CURRENT_SLOPE_AFTER_THRESHOLD);
  mDic.add("fall_current_slope_before_threshold", ATTR_FALL_CURRENT_SLOPE_BEFORE_THRESHOLD);
  mDic.add("fall_delay_intercept", ATTR_FALL_DELAY_INTERCEPT);
  mDic.add("fall_pin_resistance", ATTR_FALL_PIN_RESISTANCE);
  mDic.add("fall_power", ATTR_FALL_POWER);
  mDic.add("fall_propagation", ATTR_FALL_PROPAGATION);
  mDic.add("fall_resistance", ATTR_FALL_RESISTANCE);
  mDic.add("fall_time_after_threshold", ATTR_FALL_TIME_AFTER_THRESHOLD);
  mDic.add("fall_time_before_threshold", ATTR_FALL_TIME_BEFORE_THRESHOLD);
  mDic.add("fall_transition_degradation", ATTR_FALL_TRANSITION_DEGRADATION);
  mDic.add("fall_transition", ATTR_FALL_TRANSITION);
  mDic.add("falling_together_group", ATTR_FALLING_TOGETHER_GROUP);
  mDic.add("fanout_area", ATTR_FANOUT_AREA);
  mDic.add("fanout_capacitance", ATTR_FANOUT_CAPACITANCE);
  mDic.add("fanout_length", ATTR_FANOUT_LENGTH);
  mDic.add("fanout_load", ATTR_FANOUT_LOAD);
  mDic.add("fanout_resistance", ATTR_FANOUT_RESISTANCE);
  mDic.add("fault_model", ATTR_FAULT_MODEL);
  mDic.add("faults_lut_template", ATTR_FAULTS_LUT_TEMPLATE);
  mDic.add("ff_bank", ATTR_FF_BANK);
  mDic.add("ff", ATTR_FF);
  mDic.add("fpga_domain_style", ATTR_FPGA_DOMAIN_STYLE);
  mDic.add("fpga_technology", ATTR_FPGA_TECHNOLOGY);
  mDic.add("function", ATTR_FUNCTION);
  mDic.add("functional_yield_metric", ATTR_FUNCTIONAL_YIELD_METRIC);
  mDic.add("generated_clock", ATTR_GENERATED_CLOCK);
  mDic.add("geometry_print", ATTR_GEOMETRY_PRINT);
  mDic.add("handle_negative_constraint", ATTR_HANDLE_NEGATIVE_CONSTRAINT);
  mDic.add("has_builtin_pad", ATTR_HAS_BUILTIN_PAD);
  mDic.add("hyperbolic_noise_above_high", ATTR_HYPERBOLIC_NOISE_ABOVE_HIGH);
  mDic.add("hyperbolic_noise_below_low", ATTR_HYPERBOLIC_NOISE_BELOW_LOW);
  mDic.add("hyperbolic_noise_high", ATTR_HYPERBOLIC_NOISE_HIGH);
  mDic.add("hyperbolic_noise_low", ATTR_HYPERBOLIC_NOISE_LOW);
  mDic.add("hysteresis", ATTR_HYSTERESIS);
  mDic.add("in_place_swap_mode", ATTR_IN_PLACE_SWAP_MODE);
  mDic.add("index_1", ATTR_INDEX_1);
  mDic.add("index_2", ATTR_INDEX_2);
  mDic.add("index_3", ATTR_INDEX_3);
  mDic.add("input_map", ATTR_INPUT_MAP);
  mDic.add("input_signal_level", ATTR_INPUT_SIGNAL_LEVEL);
  mDic.add("input_threshold_pct_fall", ATTR_INPUT_THRESHOLD_PCT_FALL);
  mDic.add("input_threshold_pct_rise", ATTR_INPUT_THRESHOLD_PCT_RISE);
  mDic.add("input_voltage", ATTR_INPUT_VOLTAGE);
  mDic.add("interface_timing", ATTR_INTERFACE_TIMING);
  mDic.add("internal_node", ATTR_INTERNAL_NODE);
  mDic.add("internal_power", ATTR_INTERNAL_POWER);
  mDic.add("intrinsic_fall", ATTR_INTRINSIC_FALL);
  mDic.add("intrinsic_parasitic", ATTR_INTRINSIC_PARASITIC);
  mDic.add("intrinsic_rise", ATTR_INTRINSIC_RISE);
  mDic.add("inverted_output", ATTR_INVERTED_OUTPUT);
  mDic.add("io_type", ATTR_IO_TYPE);
  mDic.add("is_clock_gating_cell", ATTR_IS_CLOCK_GATING_CELL);
  mDic.add("is_filler_cell", ATTR_IS_FILLER_CELL);
  mDic.add("is_pad", ATTR_IS_PAD);
  mDic.add("iv_lut_template", ATTR_IV_LUT_TEMPLATE);
  mDic.add("k_process_cell_fall", ATTR_K_PROCESS_CELL_FALL);
  mDic.add("k_process_cell_leakage_power", ATTR_K_PROCESS_CELL_LEAKAGE_POWER);
  mDic.add("k_process_cell_rise", ATTR_K_PROCESS_CELL_RISE);
  mDic.add("k_process_drive_current", ATTR_K_PROCESS_DRIVE_CURRENT);
  mDic.add("k_process_drive_fall", ATTR_K_PROCESS_DRIVE_FALL);
  mDic.add("k_process_drive_rise", ATTR_K_PROCESS_DRIVE_RISE);
  mDic.add("k_process_fall_delay_intercept", ATTR_K_PROCESS_FALL_DELAY_INTERCEPT);
  mDic.add("k_process_fall_pin_resistance", ATTR_K_PROCESS_FALL_PIN_RESISTANCE);
  mDic.add("k_process_fall_propagation", ATTR_K_PROCESS_FALL_PROPAGATION);
  mDic.add("k_process_fall_transition", ATTR_K_PROCESS_FALL_TRANSITION);
  mDic.add("k_process_hold_fall", ATTR_K_PROCESS_HOLD_FALL);
  mDic.add("k_process_hold_rise", ATTR_K_PROCESS_HOLD_RISE);
  mDic.add("k_process_internal_power", ATTR_K_PROCESS_INTERNAL_POWER);
  mDic.add("k_process_intrinsic_fall", ATTR_K_PROCESS_INTRINSIC_FALL);
  mDic.add("k_process_intrinsic_rise", ATTR_K_PROCESS_INTRINSIC_RISE);
  mDic.add("k_process_min_period", ATTR_K_PROCESS_MIN_PERIOD);
  mDic.add("k_process_min_pulse_width_high", ATTR_K_PROCESS_MIN_PULSE_WIDTH_HIGH);
  mDic.add("k_process_min_pulse_width_low", ATTR_K_PROCESS_MIN_PULSE_WIDTH_LOW);
  mDic.add("k_process_nochange_fall", ATTR_K_PROCESS_NOCHANGE_FALL);
  mDic.add("k_process_nochange_rise", ATTR_K_PROCESS_NOCHANGE_RISE);
  mDic.add("k_process_pin_cap", ATTR_K_PROCESS_PIN_CAP);
  mDic.add("k_process_recovery_fall", ATTR_K_PROCESS_RECOVERY_FALL);
  mDic.add("k_process_recovery_rise", ATTR_K_PROCESS_RECOVERY_RISE);
  mDic.add("k_process_removal_fall", ATTR_K_PROCESS_REMOVAL_FALL);
  mDic.add("k_process_removal_rise", ATTR_K_PROCESS_REMOVAL_RISE);
  mDic.add("k_process_rise_transition", ATTR_K_PROCESS_RISE_TRANSITION);
  mDic.add("k_process_rise_delay_intercept", ATTR_K_PROCESS_RISE_DELAY_INTERCEPT);
  mDic.add("k_process_rise_pin_resistance", ATTR_K_PROCESS_RISE_PIN_RESISTANCE);
  mDic.add("k_process_rise_propagation", ATTR_K_PROCESS_RISE_PROPAGATION);
  mDic.add("k_process_setup_fall", ATTR_K_PROCESS_SETUP_FALL);
  mDic.add("k_process_setup_rise", ATTR_K_PROCESS_SETUP_RISE);
  mDic.add("k_process_skew_fall", ATTR_K_PROCESS_SKEW_FALL);
  mDic.add("k_process_skew_rise", ATTR_K_PROCESS_SKEW_RISE);
  mDic.add("k_process_slope_fall", ATTR_K_PROCESS_SLOPE_FALL);
  mDic.add("k_process_slope_rise", ATTR_K_PROCESS_SLOPE_RISE);
  mDic.add("k_process_wire_cap", ATTR_K_PROCESS_WIRE_CAP);
  mDic.add("k_process_wire_res", ATTR_K_PROCESS_WIRE_RES);
  mDic.add("k_temp_cell_fall", ATTR_K_TEMP_CELL_FALL);
  mDic.add("k_temp_cell_leakage_power", ATTR_K_TEMP_CELL_LEAKAGE_POWER);
  mDic.add("k_temp_cell_rise", ATTR_K_TEMP_CELL_RISE);
  mDic.add("k_temp_drive_current", ATTR_K_TEMP_DRIVE_CURRENT);
  mDic.add("k_temp_drive_fall", ATTR_K_TEMP_DRIVE_FALL);
  mDic.add("k_temp_drive_rise", ATTR_K_TEMP_DRIVE_RISE);
  mDic.add("k_temp_fall_delay_intercept", ATTR_K_TEMP_FALL_DELAY_INTERCEPT);
  mDic.add("k_temp_fall_pin_resistance", ATTR_K_TEMP_FALL_PIN_RESISTANCE);
  mDic.add("k_temp_fall_propagation", ATTR_K_TEMP_FALL_PROPAGATION);
  mDic.add("k_temp_fall_transition", ATTR_K_TEMP_FALL_TRANSITION);
  mDic.add("k_temp_hold_fall", ATTR_K_TEMP_HOLD_FALL);
  mDic.add("k_temp_hold_rise", ATTR_K_TEMP_HOLD_RISE);
  mDic.add("k_temp_internal_power", ATTR_K_TEMP_INTERNAL_POWER);
  mDic.add("k_temp_intrinsic_fall", ATTR_K_TEMP_INTRINSIC_FALL);
  mDic.add("k_temp_intrinsic_rise", ATTR_K_TEMP_INTRINSIC_RISE);
  mDic.add("k_temp_min_period", ATTR_K_TEMP_MIN_PERIOD);
  mDic.add("k_temp_min_pulse_width_high", ATTR_K_TEMP_MIN_PULSE_WIDTH_HIGH);
  mDic.add("k_temp_min_pulse_width_low", ATTR_K_TEMP_MIN_PULSE_WIDTH_LOW);
  mDic.add("k_temp_nochange_fall", ATTR_K_TEMP_NOCHANGE_FALL);
  mDic.add("k_temp_nochange_rise", ATTR_K_TEMP_NOCHANGE_RISE);
  mDic.add("k_temp_pin_cap", ATTR_K_TEMP_PIN_CAP);
  mDic.add("k_temp_recovery_fall", ATTR_K_TEMP_RECOVERY_FALL);
  mDic.add("k_temp_recovery_rise", ATTR_K_TEMP_RECOVERY_RISE);
  mDic.add("k_temp_removal_fall", ATTR_K_TEMP_REMOVAL_FALL);
  mDic.add("k_temp_removal_rise", ATTR_K_TEMP_REMOVAL_RISE);
  mDic.add("k_temp_rise_transition", ATTR_K_TEMP_RISE_TRANSITION);
  mDic.add("k_temp_rise_delay_intercept", ATTR_K_TEMP_RISE_DELAY_INTERCEPT);
  mDic.add("k_temp_rise_pin_resistance", ATTR_K_TEMP_RISE_PIN_RESISTANCE);
  mDic.add("k_temp_rise_propagation", ATTR_K_TEMP_RISE_PROPAGATION);
  mDic.add("k_temp_setup_fall", ATTR_K_TEMP_SETUP_FALL);
  mDic.add("k_temp_setup_rise", ATTR_K_TEMP_SETUP_RISE);
  mDic.add("k_temp_skew_fall", ATTR_K_TEMP_SKEW_FALL);
  mDic.add("k_temp_skew_rise", ATTR_K_TEMP_SKEW_RISE);
  mDic.add("k_temp_slope_fall", ATTR_K_TEMP_SLOPE_FALL);
  mDic.add("k_temp_slope_rise", ATTR_K_TEMP_SLOPE_RISE);
  mDic.add("k_temp_wire_cap", ATTR_K_TEMP_WIRE_CAP);
  mDic.add("k_temp_wire_res", ATTR_K_TEMP_WIRE_RES);
  mDic.add("k_volt_cell_fall", ATTR_K_VOLT_CELL_FALL);
  mDic.add("k_volt_cell_leakage_power", ATTR_K_VOLT_CELL_LEAKAGE_POWER);
  mDic.add("k_volt_cell_rise", ATTR_K_VOLT_CELL_RISE);
  mDic.add("k_volt_drive_current", ATTR_K_VOLT_DRIVE_CURRENT);
  mDic.add("k_volt_drive_fall", ATTR_K_VOLT_DRIVE_FALL);
  mDic.add("k_volt_drive_rise", ATTR_K_VOLT_DRIVE_RISE);
  mDic.add("k_volt_fall_delay_intercept", ATTR_K_VOLT_FALL_DELAY_INTERCEPT);
  mDic.add("k_volt_fall_pin_resistance", ATTR_K_VOLT_FALL_PIN_RESISTANCE);
  mDic.add("k_volt_fall_propagation", ATTR_K_VOLT_FALL_PROPAGATION);
  mDic.add("k_volt_fall_transition", ATTR_K_VOLT_FALL_TRANSITION);
  mDic.add("k_volt_hold_fall", ATTR_K_VOLT_HOLD_FALL);
  mDic.add("k_volt_hold_rise", ATTR_K_VOLT_HOLD_RISE);
  mDic.add("k_volt_internal_power", ATTR_K_VOLT_INTERNAL_POWER);
  mDic.add("k_volt_intrinsic_fall", ATTR_K_VOLT_INTRINSIC_FALL);
  mDic.add("k_volt_intrinsic_rise", ATTR_K_VOLT_INTRINSIC_RISE);
  mDic.add("k_volt_min_period", ATTR_K_VOLT_MIN_PERIOD);
  mDic.add("k_volt_min_pulse_width_high", ATTR_K_VOLT_MIN_PULSE_WIDTH_HIGH);
  mDic.add("k_volt_min_pulse_width_low", ATTR_K_VOLT_MIN_PULSE_WIDTH_LOW);
  mDic.add("k_volt_nochange_fall", ATTR_K_VOLT_NOCHANGE_FALL);
  mDic.add("k_volt_nochange_rise", ATTR_K_VOLT_NOCHANGE_RISE);
  mDic.add("k_volt_pin_cap", ATTR_K_VOLT_PIN_CAP);
  mDic.add("k_volt_recovery_fall", ATTR_K_VOLT_RECOVERY_FALL);
  mDic.add("k_volt_recovery_rise", ATTR_K_VOLT_RECOVERY_RISE);
  mDic.add("k_volt_removal_fall", ATTR_K_VOLT_REMOVAL_FALL);
  mDic.add("k_volt_removal_rise", ATTR_K_VOLT_REMOVAL_RISE);
  mDic.add("k_volt_rise_transition", ATTR_K_VOLT_RISE_TRANSITION);
  mDic.add("k_volt_rise_delay_intercept", ATTR_K_VOLT_RISE_DELAY_INTERCEPT);
  mDic.add("k_volt_rise_pin_resistance", ATTR_K_VOLT_RISE_PIN_RESISTANCE);
  mDic.add("k_volt_rise_propagation", ATTR_K_VOLT_RISE_PROPAGATION);
  mDic.add("k_volt_setup_fall", ATTR_K_VOLT_SETUP_FALL);
  mDic.add("k_volt_setup_rise", ATTR_K_VOLT_SETUP_RISE);
  mDic.add("k_volt_skew_fall", ATTR_K_VOLT_SKEW_FALL);
  mDic.add("k_volt_skew_rise", ATTR_K_VOLT_SKEW_RISE);
  mDic.add("k_volt_slope_fall", ATTR_K_VOLT_SLOPE_FALL);
  mDic.add("k_volt_slope_rise", ATTR_K_VOLT_SLOPE_RISE);
  mDic.add("k_volt_wire_cap", ATTR_K_VOLT_WIRE_CAP);
  mDic.add("k_volt_wire_res", ATTR_K_VOLT_WIRE_RES);
  mDic.add("latch_bank", ATTR_LATCH_BANK);
  mDic.add("latch", ATTR_LATCH);
  mDic.add("leakage_current", ATTR_LEAKAGE_CURRENT);
  mDic.add("leakage_power_unit", ATTR_LEAKAGE_POWER_UNIT);
  mDic.add("leakage_power", ATTR_LEAKAGE_POWER);
  mDic.add("library_features", ATTR_LIBRARY_FEATURES);
  mDic.add("library", ATTR_LIBRARY);
  mDic.add("lu_table_template", ATTR_LU_TABLE_TEMPLATE);
  mDic.add("lut", ATTR_LUT);
  mDic.add("map_only", ATTR_MAP_ONLY);
  mDic.add("max_capacitance", ATTR_MAX_CAPACITANCE);
  mDic.add("max_fanout", ATTR_MAX_FANOUT);
  mDic.add("max_input_noise_width", ATTR_MAX_INPUT_NOISE_WIDTH);
  mDic.add("max_trans", ATTR_MAX_TRANS);
  mDic.add("max_transition", ATTR_MAX_TRANSITION);
  mDic.add("members", ATTR_MEMBERS);
  mDic.add("min_capacitance", ATTR_MIN_CAPACITANCE);
  mDic.add("min_fanout", ATTR_MIN_FANOUT);
  mDic.add("min_input_noise_width", ATTR_MIN_INPUT_NOISE_WIDTH);
  mDic.add("min_period", ATTR_MIN_PERIOD);
  mDic.add("min_pulse_width_high", ATTR_MIN_PULSE_WIDTH_HIGH);
  mDic.add("min_pulse_width_low", ATTR_MIN_PULSE_WIDTH_LOW);
  mDic.add("min_pulse_width", ATTR_MIN_PULSE_WIDTH);
  mDic.add("min_transition", ATTR_MIN_TRANSITION);
  mDic.add("minimum_period", ATTR_MINIMUM_PERIOD);
  mDic.add("mode_definition", ATTR_MODE_DEFINITION);
  mDic.add("multicell_pad_pin", ATTR_MULTICELL_PAD_PIN);
  mDic.add("next_state", ATTR_NEXT_STATE);
  mDic.add("nextstate_type", ATTR_NEXTSTATE_TYPE);
  mDic.add("noise_immunity_above_high", ATTR_NOISE_IMMUNITY_ABOVE_HIGH);
  mDic.add("noise_immunity_below_low", ATTR_NOISE_IMMUNITY_BELOW_LOW);
  mDic.add("noise_immunity_high", ATTR_NOISE_IMMUNITY_HIGH);
  mDic.add("noise_immunity_low", ATTR_NOISE_IMMUNITY_LOW);
  mDic.add("noise_lut_template", ATTR_NOISE_LUT_TEMPLATE);
  mDic.add("nom_calc_mode", ATTR_NOM_CALC_MODE);
  mDic.add("nom_process", ATTR_NOM_PROCESS);
  mDic.add("nom_temperature", ATTR_NOM_TEMPERATURE);
  mDic.add("nom_voltage", ATTR_NOM_VOLTAGE);
  mDic.add("operating_conditions", ATTR_OPERATING_CONDITIONS);
  mDic.add("orders", ATTR_ORDERS);
  mDic.add("output_current_template", ATTR_OUTPUT_CURRENT_TEMPLATE);
  mDic.add("output_signal_level", ATTR_OUTPUT_SIGNAL_LEVEL);
  mDic.add("output_threshold_pct_fall", ATTR_OUTPUT_THRESHOLD_PCT_FALL);
  mDic.add("output_threshold_pct_rise", ATTR_OUTPUT_THRESHOLD_PCT_RISE);
  mDic.add("output_voltage", ATTR_OUTPUT_VOLTAGE);
  mDic.add("pad_cell", ATTR_PAD_CELL);
  mDic.add("pad_type", ATTR_PAD_TYPE);
  mDic.add("parameter1", ATTR_PARAMETER1);
  mDic.add("parameter2", ATTR_PARAMETER2);
  mDic.add("parameter3", ATTR_PARAMETER3);
  mDic.add("parameter4", ATTR_PARAMETER4);
  mDic.add("parameter5", ATTR_PARAMETER5);
  mDic.add("part", ATTR_PART);
  mDic.add("piece_define", ATTR_PIECE_DEFINE);
  mDic.add("piece_type", ATTR_PIECE_TYPE);
  mDic.add("pin_func_type", ATTR_PIN_FUNC_TYPE);
  mDic.add("pin_opposite", ATTR_PIN_OPPOSITE);
  mDic.add("pin", ATTR_PIN);
  mDic.add("poly_template", ATTR_POLY_TEMPLATE);
  mDic.add("power_cell_type", ATTR_POWER_CELL_TYPE);
  mDic.add("power_level", ATTR_POWER_LEVEL);
  mDic.add("power_lut_template", ATTR_POWER_LUT_TEMPLATE);
  mDic.add("power_poly_template", ATTR_POWER_POLY_TEMPLATE);
  mDic.add("power_model", ATTR_POWER_MODEL);
  mDic.add("power_rail", ATTR_POWER_RAIL);
  mDic.add("power_supply_namestring", ATTR_POWER_SUPPLY_NAMESTRING);
  mDic.add("power_supply", ATTR_POWER_SUPPLY);
  mDic.add("power", ATTR_POWER);
  mDic.add("prefer_tied", ATTR_PREFER_TIED);
  mDic.add("preferred", ATTR_PREFERRED);
  mDic.add("preferred_input_pad_voltage", ATTR_PREFERRED_INPUT_PAD_VOLTAGE);
  mDic.add("preferred_output_pad_slew_rate_control", ATTR_PREFERRED_OUTPUT_PAD_SLEW_RATE_CONTROL);
  mDic.add("preferred_output_pad_voltage", ATTR_PREFERRED_OUTPUT_PAD_VOLTAGE);
  mDic.add("preset", ATTR_PRESET);
  mDic.add("primary_output", ATTR_PRIMARY_OUTPUT);
  mDic.add("process", ATTR_PROCESS);
  mDic.add("propagated_noise_height_above_high", ATTR_PROPAGATED_NOISE_HEIGHT_ABOVE_HIGH);
  mDic.add("propagated_noise_height_below_low", ATTR_PROPAGATED_NOISE_HEIGHT_BELOW_LOW);
  mDic.add("propagated_noise_height_high", ATTR_PROPAGATED_NOISE_HEIGHT_HIGH);
  mDic.add("propagated_noise_height_low", ATTR_PROPAGATED_NOISE_HEIGHT_LOW);
  mDic.add("propagated_noise_peak_time_ratio_above_high", ATTR_PROPAGATED_NOISE_PEAK_TIME_RATIO_ABOVE_HIGH);
  mDic.add("propagated_noise_peak_time_ratio_below_low", ATTR_PROPAGATED_NOISE_PEAK_TIME_RATIO_BELOW_LOW);
  mDic.add("propagated_noise_peak_time_ratio_high", ATTR_PROPAGATED_NOISE_PEAK_TIME_RATIO_HIGH);
  mDic.add("propagated_noise_peak_time_ratio_low", ATTR_PROPAGATED_NOISE_PEAK_TIME_RATIO_LOW);
  mDic.add("propagated_noise_width_above_high", ATTR_PROPAGATED_NOISE_WIDTH_ABOVE_HIGH);
  mDic.add("propagated_noise_width_below_low", ATTR_PROPAGATED_NOISE_WIDTH_BELOW_LOW);
  mDic.add("propagated_noise_width_high", ATTR_PROPAGATED_NOISE_WIDTH_HIGH);
  mDic.add("propagated_noise_width_low", ATTR_PROPAGATED_NOISE_WIDTH_LOW);
  mDic.add("propagation_lut_template", ATTR_PROPAGATION_LUT_TEMPLATE);
  mDic.add("pulling_current", ATTR_PULLING_CURRENT);
  mDic.add("pulling_resistance_unit", ATTR_PULLING_RESISTANCE_UNIT);
  mDic.add("pulling_resistance", ATTR_PULLING_RESISTANCE);
  mDic.add("rail_connection", ATTR_RAIL_CONNECTION);
  mDic.add("related_bus_equivalent", ATTR_RELATED_BUS_EQUIVALENT);
  mDic.add("related_bus_pins", ATTR_RELATED_BUS_PINS);
  mDic.add("related_inputs", ATTR_RELATED_INPUTS);
  mDic.add("related_output_pin", ATTR_RELATED_OUTPUT_PIN);
  mDic.add("related_outputs", ATTR_RELATED_OUTPUTS);
  mDic.add("related_pg_pin", ATTR_RELATED_PG_PIN);
  mDic.add("related_pin", ATTR_RELATED_PIN);
  mDic.add("resistance", ATTR_RESISTANCE);
  mDic.add("resource_usage", ATTR_RESOURCE_USAGE);
  mDic.add("retain_fall_slew", ATTR_RETAIN_FALL_SLEW);
  mDic.add("retain_rise_slew", ATTR_RETAIN_RISE_SLEW);
  mDic.add("retaining_fall", ATTR_RETAINING_FALL);
  mDic.add("retaining_rise", ATTR_RETAINING_RISE);
  mDic.add("revision", ATTR_REVISION);
  mDic.add("rise_capacitance_range", ATTR_RISE_CAPACITANCE_RANGE);
  mDic.add("rise_capacitance", ATTR_RISE_CAPACITANCE);
  mDic.add("rise_constraint", ATTR_RISE_CONSTRAINT);
  mDic.add("rise_current_slope_after_threshold", ATTR_RISE_CURRENT_SLOPE_AFTER_THRESHOLD);
  mDic.add("rise_current_slope_before_threshold", ATTR_RISE_CURRENT_SLOPE_BEFORE_THRESHOLD);
  mDic.add("rise_delay_intercept", ATTR_RISE_DELAY_INTERCEPT);
  mDic.add("rise_pin_resistance", ATTR_RISE_PIN_RESISTANCE);
  mDic.add("rise_power", ATTR_RISE_POWER);
  mDic.add("rise_propagation", ATTR_RISE_PROPAGATION);
  mDic.add("rise_resistance", ATTR_RISE_RESISTANCE);
  mDic.add("rise_time_after_threshold", ATTR_RISE_TIME_AFTER_THRESHOLD);
  mDic.add("rise_time_before_threshold", ATTR_RISE_TIME_BEFORE_THRESHOLD);
  mDic.add("rise_transition_degradation", ATTR_RISE_TRANSITION_DEGRADATION);
  mDic.add("rise_transition", ATTR_RISE_TRANSITION);
  mDic.add("rising_together_group", ATTR_RISING_TOGETHER_GROUP);
  mDic.add("routing_layers", ATTR_ROUTING_LAYERS);
  mDic.add("routing_track", ATTR_ROUTING_TRACK);
  mDic.add("scaled_cell", ATTR_SCALED_CELL);
  mDic.add("scaling_factors", ATTR_SCALING_FACTORS);
  mDic.add("sdf_cond_end", ATTR_SDF_COND_END);
  mDic.add("sdf_cond_start", ATTR_SDF_COND_START);
  mDic.add("sdf_cond", ATTR_SDF_COND);
  mDic.add("sdf_edges", ATTR_SDF_EDGES);
  mDic.add("signal_type", ATTR_SIGNAL_TYPE);
  mDic.add("simulation", ATTR_SIMULATION);
  mDic.add("single_bit_degenerate", ATTR_SINGLE_BIT_DEGENERATE);
  mDic.add("slew_control", ATTR_SLEW_CONTROL);
  mDic.add("slew_derate_from_library", ATTR_SLEW_DERATE_FROM_LIBRARY);
  mDic.add("slew_lower_threshold_pct_fall", ATTR_SLEW_LOWER_THRESHOLD_PCT_FALL);
  mDic.add("slew_lower_threshold_pct_rise", ATTR_SLEW_LOWER_THRESHOLD_PCT_RISE);
  mDic.add("slew_type", ATTR_SLEW_TYPE);
  mDic.add("slew_upper_threshold_pct_fall", ATTR_SLEW_UPPER_THRESHOLD_PCT_FALL);
  mDic.add("slew_upper_threshold_pct_rise", ATTR_SLEW_UPPER_THRESHOLD_PCT_RISE);
  mDic.add("slope_fall", ATTR_SLOPE_FALL);
  mDic.add("slope_rise", ATTR_SLOPE_RISE);
  mDic.add("slope", ATTR_SLOPE);
  mDic.add("state_function", ATTR_STATE_FUNCTION);
  mDic.add("statetable", ATTR_STATETABLE);
  mDic.add("steady_state_current_high", ATTR_STEADY_STATE_CURRENT_HIGH);
  mDic.add("steady_state_current_low", ATTR_STEADY_STATE_CURRENT_LOW);
  mDic.add("steady_state_current_tristate", ATTR_STEADY_STATE_CURRENT_TRISTATE);
  mDic.add("switching_interval", ATTR_SWITCHING_INTERVAL);
  mDic.add("switching_together_group", ATTR_SWITCHING_TOGETHER_GROUP);
  mDic.add("table", ATTR_TABLE);
  mDic.add("technology", ATTR_TECHNOLOGY);
  mDic.add("temperature", ATTR_TEMPERATURE);
  mDic.add("test_cell", ATTR_TEST_CELL);
  mDic.add("test_output_only", ATTR_TEST_OUTPUT_ONLY);
  mDic.add("three_state", ATTR_THREE_STATE);
  mDic.add("time_unit", ATTR_TIME_UNIT);
  mDic.add("timing_model_type", ATTR_TIMING_MODEL_TYPE);
  mDic.add("timing_range", ATTR_TIMING_RANGE);
  mDic.add("timing_sense", ATTR_TIMING_SENSE);
  mDic.add("timing_type", ATTR_TIMING_TYPE);
  mDic.add("timing", ATTR_TIMING);
  mDic.add("tlatch", ATTR_TLATCH);
  mDic.add("tree_type", ATTR_TREE_TYPE);
  mDic.add("type", ATTR_TYPE);
  mDic.add("use_for_size_only", ATTR_USE_FOR_SIZE_ONLY);
  mDic.add("value", ATTR_VALUE);
  mDic.add("values", ATTR_VALUES);
  mDic.add("variable_1", ATTR_VARIABLE_1);
  mDic.add("variable_2", ATTR_VARIABLE_2);
  mDic.add("variable_3", ATTR_VARIABLE_3);
  mDic.add("vhdl_name", ATTR_VHDL_NAME);
  mDic.add("vih", ATTR_VIH);
  mDic.add("vil", ATTR_VIL);
  mDic.add("vimax", ATTR_VIMAX);
  mDic.add("vimin", ATTR_VIMIN);
  mDic.add("voh", ATTR_VOH);
  mDic.add("vol", ATTR_VOL);
  mDic.add("voltage_unit", ATTR_VOLTAGE_UNIT);
  mDic.add("voltage", ATTR_VOLTAGE);
  mDic.add("vomax", ATTR_VOMAX);
  mDic.add("vomin", ATTR_VOMIN);
  mDic.add("when_end", ATTR_WHEN_END);
  mDic.add("when_start", ATTR_WHEN_START);
  mDic.add("when", ATTR_WHEN);
  mDic.add("wire_load_from_area", ATTR_WIRE_LOAD_FROM_AREA);
  mDic.add("wire_load_selection", ATTR_WIRE_LOAD_SELECTION);
  mDic.add("wire_load_table", ATTR_WIRE_LOAD_TABLE);
  mDic.add("wire_load", ATTR_WIRE_LOAD);
  mDic.add("x_function", ATTR_X_FUNCTION);
}

// @brief デストラクタ
AttrDic::~AttrDic()
{
}

// @brief 文字列を属性値に変換する．
// @param[in] str 文字列
// @return str に対応する AttrType の値
//
// 対応する値がない場合は ATTR_NONE を返す．
AttrType
AttrDic::get(const char* str) const
{
  if ( mDic.check(str) ) {
    return mDic[str];
  }
  else {
    return ATTR_NONE;
  }
}

// @brief AttrType の内容をストリームに出力する．
ostream&
operator<<(ostream& s,
	   AttrType attr)
{
  switch ( attr ) {
  case ATTR_NONE: s << "none"; break;
  case ATTR_AREA: s << "area"; break;
  case ATTR_AUXILIARY_PAD_CELL: s << "auxiliary_pad_cell"; break;
  case ATTR_BASE_NAME: s << "base_name"; break;
  case ATTR_BIT_WIDTH: s << "bit_width"; break;
  case ATTR_BUNDLE: s << "bundle"; break;
  case ATTR_BUS_NAMING_STYLE: s << "bus_naming_style"; break;
  case ATTR_BUS_TYPE: s << "bus_type"; break;
  case ATTR_BUS: s << "bus"; break;
  case ATTR_CALC_MODE: s << "calc_mode"; break;
  case ATTR_CAPACITANCE: s << "capacitance"; break;
  case ATTR_CAPACITIVE_LOAD_UNIT: s << "capacitive_load_unit"; break;
  case ATTR_CELL_DEGRADATION: s << "cell_degradation"; break;
  case ATTR_CELL_FALL: s << "cell_fall"; break;
  case ATTR_CELL_FOOTPRINT: s << "cell_footprint"; break;
  case ATTR_CELL_LEAKAGE_POWER: s << "cell_leakage_power"; break;
  case ATTR_CELL_RISE: s << "cell_rise"; break;
  case ATTR_CELL: s << "cell"; break;
  case ATTR_CLEAR_PRESET_VAR1: s << "clear_preset_var1"; break;
  case ATTR_CLEAR_PRESET_VAR2: s << "clear_preset_var2"; break;
  case ATTR_CLEAR: s << "clear"; break;
  case ATTR_CLOCK_GATE_CLOCK_PIN: s << "clock_gate_clock_pin"; break;
  case ATTR_CLOCK_GATE_ENABLE_PIN: s << "clock_gate_enable_pin"; break;
  case ATTR_CLOCK_GATE_TEST_PIN: s << "clock_gate_test_pin"; break;
  case ATTR_CLOCK_GATE_OBS_PIN: s << "clock_gate_obs_pin"; break;
  case ATTR_CLOCK_GATE_OUT_PIN: s << "clock_gate_out_pin"; break;
  case ATTR_CLOCK_GATING_INTEGRATED_CELL: s << "clock_gating_integrated_cell"; break;
  case ATTR_CLOCK: s << "clock"; break;
  case ATTR_CLOCKED_ON_ALSO: s << "clocked_on_also"; break;
  case ATTR_CLOCKED_ON: s << "clocked_on"; break;
  case ATTR_COEFS: s << "coefs"; break;
  case ATTR_COMMENT: s << "comment"; break;
  case ATTR_COMPLEMENTARY_PIN: s << "complementary_pin"; break;
  case ATTR_CONNECTION_CLASS: s << "connection_class"; break;
  case ATTR_CONTENTION_CONDITION: s << "contention_condition"; break;
  case ATTR_CURRENT_UNIT: s << "current_unit"; break;
  case ATTR_DATA_IN: s << "data_in"; break;
  case ATTR_DATE: s << "date"; break;
  case ATTR_DC_CURRENT_TEMPLATE: s << "dc_current_template"; break;
  case ATTR_DEFAULT_CELL_LEAKAGE_POWER: s << "default_cell_leakage_power"; break;
  case ATTR_DEFAULT_CONNECTION_CLASS: s << "default_connection_class"; break;
  case ATTR_DEFAULT_FALL_DELAY_INTERCEPT: s << "default_fall_delay_intercept"; break;
  case ATTR_DEFAULT_FALL_PIN_RESISTANCE: s << "default_fall_pin_resistance"; break;
  case ATTR_DEFAULT_FANOUT_LOAD: s << "default_fanout_load"; break;
  case ATTR_DEFAULT_INOUT_PIN_CAP: s << "default_inout_pin_cap"; break;
  case ATTR_DEFAULT_INOUT_PIN_FALL_RES: s << "default_inout_pin_fall_res"; break;
  case ATTR_DEFAULT_INOUT_PIN_RISE_RES: s << "default_inout_pin_rise_res"; break;
  case ATTR_DEFAULT_INPUT_PIN_CAP: s << "default_input_pin_cap"; break;
  case ATTR_DEFAULT_INTRINSIC_FALL: s << "default_intrinsic_fall"; break;
  case ATTR_DEFAULT_INTRINSIC_RISE: s << "default_intrinsic_rise"; break;
  case ATTR_DEFAULT_LEAKAGE_POWER_DENSITY: s << "default_leakage_power_density"; break;
  case ATTR_DEFAULT_MAX_CAPACITANCE: s << "default_max_capacitance"; break;
  case ATTR_DEFAULT_MAX_FANOUT: s << "default_max_fanout"; break;
  case ATTR_DEFAULT_MAX_TRANSITION: s << "default_max_transition"; break;
  case ATTR_DEFAULT_MAX_UTILIZATION: s << "default_max_utilization"; break;
  case ATTR_DEFAULT_MIN_POROSITY: s << "default_min_porosity"; break;
  case ATTR_DEFAULT_OPERATING_CONDITIONS: s << "default_operating_conditions"; break;
  case ATTR_DEFAULT_OUTPUT_PIN_CAP: s << "default_output_pin_cap"; break;
  case ATTR_DEFAULT_OUTPUT_PIN_FALL_RES: s << "default_output_pin_fall_res"; break;
  case ATTR_DEFAULT_OUTPUT_PIN_RISE_RES: s << "default_output_pin_rise_res"; break;
  case ATTR_DEFAULT_PART: s << "default_part"; break;
  case ATTR_DEFAULT_RISE_DELAY_INTERCEPT: s << "default_rise_delay_intercept"; break;
  case ATTR_DEFAULT_RISE_PIN_RESISTANCE: s << "default_rise_pin_resistance"; break;
  case ATTR_DEFAULT_SLOPE_FALL: s << "default_slope_fall"; break;
  case ATTR_DEFAULT_SLOPE_RISE: s << "default_slope_rise"; break;
  case ATTR_DEFAULT_WIRE_LOAD_AREA: s << "default_wire_load_area"; break;
  case ATTR_DEFAULT_WIRE_LOAD_CAPACITANCE: s << "default_wire_load_capacitance"; break;
  case ATTR_DEFAULT_WIRE_LOAD_MODE: s << "default_wire_load_mode"; break;
  case ATTR_DEFAULT_WIRE_LOAD_RESISTANCE: s << "default_wire_load_resistance"; break;
  case ATTR_DEFAULT_WIRE_LOAD_SELECTION: s << "default_wire_load_selection"; break;
  case ATTR_DEFAULT_WIRE_LOAD: s << "default_wire_load"; break;
  case ATTR_DEFINE_CELL_AREA: s << "define_cell_area"; break;
  case ATTR_DEFINE_GROUP: s << "define_group"; break;
  case ATTR_DEFINE: s << "define"; break;
  case ATTR_DELAY_MODEL: s << "delay_model"; break;
  case ATTR_DIRECTION: s << "direction"; break;
  case ATTR_DOMAIN: s << "domain"; break;
  case ATTR_DONT_FAULT: s << "dont_fault"; break;
  case ATTR_DONT_TOUCH: s << "dont_touch"; break;
  case ATTR_DONT_USE: s << "dont_use"; break;
  case ATTR_DRIVE_CURRENT: s << "drive_current"; break;
  case ATTR_DRIVER_TYPE: s << "driver_type"; break;
  case ATTR_DYNAMIC_CURRENT: s << "dynamic_current"; break;
  case ATTR_EDGE_RATE_SENSITIVITY_F0: s << "edge_rate_sensitivity_f0"; break;
  case ATTR_EDGE_RATE_SENSITIVITY_F1: s << "edge_rate_sensitivity_f1"; break;
  case ATTR_EDGE_RATE_SENSITIVITY_R0: s << "edge_rate_sensitivity_r0"; break;
  case ATTR_EDGE_RATE_SENSITIVITY_R1: s << "edge_rate_sensitivity_r1"; break;
  case ATTR_EDIF_NAME: s << "edif_name"; break;
  case ATTR_ELECTROMIGRATION: s << "electromigration"; break;
  case ATTR_EM_LUT_TEMPLATE: s << "em_lut_template"; break;
  case ATTR_EM_TEMP_DEGRADATION_FACTOR: s << "em_temp_degradation_factor"; break;
  case ATTR_ENABLE_ALSO: s << "enable_also"; break;
  case ATTR_ENABLE: s << "enable"; break;
  case ATTR_EQUAL_OR_OPPOSITE_OUTPUT: s << "equal_or_opposite_output"; break;
  case ATTR_FALL_CAPACITANCE_RANGE: s << "fall_capacitance_range"; break;
  case ATTR_FALL_CAPACITANCE: s << "fall_capacitance"; break;
  case ATTR_FALL_CONSTRAINT: s << "fall_constraint"; break;
  case ATTR_FALL_CURRENT_SLOPE_AFTER_THRESHOLD: s << "fall_current_slope_after_threshold"; break;
  case ATTR_FALL_CURRENT_SLOPE_BEFORE_THRESHOLD: s << "fall_current_slope_before_threshold"; break;
  case ATTR_FALL_DELAY_INTERCEPT: s << "fall_delay_intercept"; break;
  case ATTR_FALL_PIN_RESISTANCE: s << "fall_pin_resistance"; break;
  case ATTR_FALL_POWER: s << "fall_power"; break;
  case ATTR_FALL_PROPAGATION: s << "fall_propagation"; break;
  case ATTR_FALL_RESISTANCE: s << "fall_resistance"; break;
  case ATTR_FALL_TIME_AFTER_THRESHOLD: s << "fall_time_after_threshold"; break;
  case ATTR_FALL_TIME_BEFORE_THRESHOLD: s << "fall_time_before_threshold"; break;
  case ATTR_FALL_TRANSITION_DEGRADATION: s << "fall_transition_degradation"; break;
  case ATTR_FALL_TRANSITION: s << "fall_transition"; break;
  case ATTR_FALLING_TOGETHER_GROUP: s << "falling_together_group"; break;
  case ATTR_FANOUT_AREA: s << "fanout_area"; break;
  case ATTR_FANOUT_CAPACITANCE: s << "fanout_capacitance"; break;
  case ATTR_FANOUT_LENGTH: s << "fanout_length"; break;
  case ATTR_FANOUT_LOAD: s << "fanout_load"; break;
  case ATTR_FANOUT_RESISTANCE: s << "fanout_resistance"; break;
  case ATTR_FAULT_MODEL: s << "fault_model"; break;
  case ATTR_FAULTS_LUT_TEMPLATE: s << "faults_lut_template"; break;
  case ATTR_FF_BANK: s << "ff_bank"; break;
  case ATTR_FF: s << "ff"; break;
  case ATTR_FPGA_DOMAIN_STYLE: s << "fpga_domain_style"; break;
  case ATTR_FPGA_TECHNOLOGY: s << "fpga_technology"; break;
  case ATTR_FUNCTION: s << "function"; break;
  case ATTR_FUNCTIONAL_YIELD_METRIC: s << "functional_yield_metric"; break;
  case ATTR_GENERATED_CLOCK: s << "generated_clock"; break;
  case ATTR_GEOMETRY_PRINT: s << "geometry_print"; break;
  case ATTR_HANDLE_NEGATIVE_CONSTRAINT: s << "handle_negative_constraint"; break;
  case ATTR_HAS_BUILTIN_PAD: s << "has_builtin_pad"; break;
  case ATTR_HYPERBOLIC_NOISE_ABOVE_HIGH: s << "hyperbolic_noise_above_high"; break;
  case ATTR_HYPERBOLIC_NOISE_BELOW_LOW: s << "hyperbolic_noise_below_low"; break;
  case ATTR_HYPERBOLIC_NOISE_HIGH: s << "hyperbolic_noise_high"; break;
  case ATTR_HYPERBOLIC_NOISE_LOW: s << "hyperbolic_noise_low"; break;
  case ATTR_HYSTERESIS: s << "hysteresis"; break;
  case ATTR_IN_PLACE_SWAP_MODE: s << "in_place_swap_mode"; break;
  case ATTR_INDEX_1: s << "index_1"; break;
  case ATTR_INDEX_2: s << "index_2"; break;
  case ATTR_INDEX_3: s << "index_3"; break;
  case ATTR_INPUT_MAP: s << "input_map"; break;
  case ATTR_INPUT_SIGNAL_LEVEL: s << "input_signal_level"; break;
  case ATTR_INPUT_THRESHOLD_PCT_FALL: s << "input_threshold_pct_fall"; break;
  case ATTR_INPUT_THRESHOLD_PCT_RISE: s << "input_threshold_pct_rise"; break;
  case ATTR_INPUT_VOLTAGE: s << "input_voltage"; break;
  case ATTR_INTERFACE_TIMING: s << "interface_timing"; break;
  case ATTR_INTERNAL_NODE: s << "internal_node"; break;
  case ATTR_INTERNAL_POWER: s << "internal_power"; break;
  case ATTR_INTRINSIC_FALL: s << "intrinsic_fall"; break;
  case ATTR_INTRINSIC_PARASITIC: s << "intrinsic_parasitic"; break;
  case ATTR_INTRINSIC_RISE: s << "intrinsic_rise"; break;
  case ATTR_INVERTED_OUTPUT: s << "inverted_output"; break;
  case ATTR_IO_TYPE: s << "io_type"; break;
  case ATTR_IS_CLOCK_GATING_CELL: s << "is_clock_gating_cell"; break;
  case ATTR_IS_FILLER_CELL: s << "is_filler_cell"; break;
  case ATTR_IS_PAD: s << "is_pad"; break;
  case ATTR_IV_LUT_TEMPLATE: s << "iv_lut_template"; break;
  case ATTR_K_PROCESS_CELL_FALL: s << "k_process_cell_fall"; break;
  case ATTR_K_PROCESS_CELL_LEAKAGE_POWER: s << "k_process_cell_leakage_power"; break;
  case ATTR_K_PROCESS_CELL_RISE: s << "k_process_cell_rise"; break;
  case ATTR_K_PROCESS_DRIVE_CURRENT: s << "k_process_drive_current"; break;
  case ATTR_K_PROCESS_DRIVE_FALL: s << "k_process_drive_fall"; break;
  case ATTR_K_PROCESS_DRIVE_RISE: s << "k_process_drive_rise"; break;
  case ATTR_K_PROCESS_FALL_DELAY_INTERCEPT: s << "k_process_fall_delay_intercept"; break;
  case ATTR_K_PROCESS_FALL_PIN_RESISTANCE: s << "k_process_fall_pin_resistance"; break;
  case ATTR_K_PROCESS_FALL_PROPAGATION: s << "k_process_fall_propagation"; break;
  case ATTR_K_PROCESS_FALL_TRANSITION: s << "k_process_fall_transition"; break;
  case ATTR_K_PROCESS_HOLD_FALL: s << "k_process_hold_fall"; break;
  case ATTR_K_PROCESS_HOLD_RISE: s << "k_process_hold_rise"; break;
  case ATTR_K_PROCESS_INTERNAL_POWER: s << "k_process_internal_power"; break;
  case ATTR_K_PROCESS_INTRINSIC_FALL: s << "k_process_intrinsic_fall"; break;
  case ATTR_K_PROCESS_INTRINSIC_RISE: s << "k_process_intrinsic_rise"; break;
  case ATTR_K_PROCESS_MIN_PERIOD: s << "k_process_min_period"; break;
  case ATTR_K_PROCESS_MIN_PULSE_WIDTH_HIGH: s << "k_process_min_pulse_width_high"; break;
  case ATTR_K_PROCESS_MIN_PULSE_WIDTH_LOW: s << "k_process_min_pulse_width_low"; break;
  case ATTR_K_PROCESS_NOCHANGE_FALL: s << "k_process_nochange_fall"; break;
  case ATTR_K_PROCESS_NOCHANGE_RISE: s << "k_process_nochange_rise"; break;
  case ATTR_K_PROCESS_PIN_CAP: s << "k_process_pin_cap"; break;
  case ATTR_K_PROCESS_RECOVERY_FALL: s << "k_process_recovery_fall"; break;
  case ATTR_K_PROCESS_RECOVERY_RISE: s << "k_process_recovery_rise"; break;
  case ATTR_K_PROCESS_REMOVAL_FALL: s << "k_process_removal_fall"; break;
  case ATTR_K_PROCESS_REMOVAL_RISE: s << "k_process_removal_rise"; break;
  case ATTR_K_PROCESS_RISE_TRANSITION: s << "k_process_rise_transition"; break;
  case ATTR_K_PROCESS_RISE_DELAY_INTERCEPT: s << "k_process_rise_delay_intercept"; break;
  case ATTR_K_PROCESS_RISE_PIN_RESISTANCE: s << "k_process_rise_pin_resistance"; break;
  case ATTR_K_PROCESS_RISE_PROPAGATION: s << "k_process_rise_propagation"; break;
  case ATTR_K_PROCESS_SETUP_FALL: s << "k_process_setup_fall"; break;
  case ATTR_K_PROCESS_SETUP_RISE: s << "k_process_setup_rise"; break;
  case ATTR_K_PROCESS_SKEW_FALL: s << "k_process_skew_fall"; break;
  case ATTR_K_PROCESS_SKEW_RISE: s << "k_process_skew_rise"; break;
  case ATTR_K_PROCESS_SLOPE_FALL: s << "k_process_slope_fall"; break;
  case ATTR_K_PROCESS_SLOPE_RISE: s << "k_process_slope_rise"; break;
  case ATTR_K_PROCESS_WIRE_CAP: s << "k_process_wire_cap"; break;
  case ATTR_K_PROCESS_WIRE_RES: s << "k_process_wire_res"; break;
  case ATTR_K_TEMP_CELL_FALL: s << "k_temp_cell_fall"; break;
  case ATTR_K_TEMP_CELL_LEAKAGE_POWER: s << "k_temp_cell_leakage_power"; break;
  case ATTR_K_TEMP_CELL_RISE: s << "k_temp_cell_rise"; break;
  case ATTR_K_TEMP_DRIVE_CURRENT: s << "k_temp_drive_current"; break;
  case ATTR_K_TEMP_DRIVE_FALL: s << "k_temp_drive_fall"; break;
  case ATTR_K_TEMP_DRIVE_RISE: s << "k_temp_drive_rise"; break;
  case ATTR_K_TEMP_FALL_DELAY_INTERCEPT: s << "k_temp_fall_delay_intercept"; break;
  case ATTR_K_TEMP_FALL_PIN_RESISTANCE: s << "k_temp_fall_pin_resistance"; break;
  case ATTR_K_TEMP_FALL_PROPAGATION: s << "k_temp_fall_propagation"; break;
  case ATTR_K_TEMP_FALL_TRANSITION: s << "k_temp_fall_transition"; break;
  case ATTR_K_TEMP_HOLD_FALL: s << "k_temp_hold_fall"; break;
  case ATTR_K_TEMP_HOLD_RISE: s << "k_temp_hold_rise"; break;
  case ATTR_K_TEMP_INTERNAL_POWER: s << "k_temp_internal_power"; break;
  case ATTR_K_TEMP_INTRINSIC_FALL: s << "k_temp_intrinsic_fall"; break;
  case ATTR_K_TEMP_INTRINSIC_RISE: s << "k_temp_intrinsic_rise"; break;
  case ATTR_K_TEMP_MIN_PERIOD: s << "k_temp_min_period"; break;
  case ATTR_K_TEMP_MIN_PULSE_WIDTH_HIGH: s << "k_temp_min_pulse_width_high"; break;
  case ATTR_K_TEMP_MIN_PULSE_WIDTH_LOW: s << "k_temp_min_pulse_width_low"; break;
  case ATTR_K_TEMP_NOCHANGE_FALL: s << "k_temp_nochange_fall"; break;
  case ATTR_K_TEMP_NOCHANGE_RISE: s << "k_temp_nochange_rise"; break;
  case ATTR_K_TEMP_PIN_CAP: s << "k_temp_pin_cap"; break;
  case ATTR_K_TEMP_RECOVERY_FALL: s << "k_temp_recovery_fall"; break;
  case ATTR_K_TEMP_RECOVERY_RISE: s << "k_temp_recovery_rise"; break;
  case ATTR_K_TEMP_REMOVAL_FALL: s << "k_temp_removal_fall"; break;
  case ATTR_K_TEMP_REMOVAL_RISE: s << "k_temp_removal_rise"; break;
  case ATTR_K_TEMP_RISE_TRANSITION: s << "k_temp_rise_transition"; break;
  case ATTR_K_TEMP_RISE_DELAY_INTERCEPT: s << "k_temp_rise_delay_intercept"; break;
  case ATTR_K_TEMP_RISE_PIN_RESISTANCE: s << "k_temp_rise_pin_resistance"; break;
  case ATTR_K_TEMP_RISE_PROPAGATION: s << "k_temp_rise_propagation"; break;
  case ATTR_K_TEMP_SETUP_FALL: s << "k_temp_setup_fall"; break;
  case ATTR_K_TEMP_SETUP_RISE: s << "k_temp_setup_rise"; break;
  case ATTR_K_TEMP_SKEW_FALL: s << "k_temp_skew_fall"; break;
  case ATTR_K_TEMP_SKEW_RISE: s << "k_temp_skew_rise"; break;
  case ATTR_K_TEMP_SLOPE_FALL: s << "k_temp_slope_fall"; break;
  case ATTR_K_TEMP_SLOPE_RISE: s << "k_temp_slope_rise"; break;
  case ATTR_K_TEMP_WIRE_CAP: s << "k_temp_wire_cap"; break;
  case ATTR_K_TEMP_WIRE_RES: s << "k_temp_wire_res"; break;
  case ATTR_K_VOLT_CELL_FALL: s << "k_volt_cell_fall"; break;
  case ATTR_K_VOLT_CELL_LEAKAGE_POWER: s << "k_volt_cell_leakage_power"; break;
  case ATTR_K_VOLT_CELL_RISE: s << "k_volt_cell_rise"; break;
  case ATTR_K_VOLT_DRIVE_CURRENT: s << "k_volt_drive_current"; break;
  case ATTR_K_VOLT_DRIVE_FALL: s << "k_volt_drive_fall"; break;
  case ATTR_K_VOLT_DRIVE_RISE: s << "k_volt_drive_rise"; break;
  case ATTR_K_VOLT_FALL_DELAY_INTERCEPT: s << "k_volt_fall_delay_intercept"; break;
  case ATTR_K_VOLT_FALL_PIN_RESISTANCE: s << "k_volt_fall_pin_resistance"; break;
  case ATTR_K_VOLT_FALL_PROPAGATION: s << "k_volt_fall_propagation"; break;
  case ATTR_K_VOLT_FALL_TRANSITION: s << "k_volt_fall_transition"; break;
  case ATTR_K_VOLT_HOLD_FALL: s << "k_volt_hold_fall"; break;
  case ATTR_K_VOLT_HOLD_RISE: s << "k_volt_hold_rise"; break;
  case ATTR_K_VOLT_INTERNAL_POWER: s << "k_volt_internal_power"; break;
  case ATTR_K_VOLT_INTRINSIC_FALL: s << "k_volt_intrinsic_fall"; break;
  case ATTR_K_VOLT_INTRINSIC_RISE: s << "k_volt_intrinsic_rise"; break;
  case ATTR_K_VOLT_MIN_PERIOD: s << "k_volt_min_period"; break;
  case ATTR_K_VOLT_MIN_PULSE_WIDTH_HIGH: s << "k_volt_min_pulse_width_high"; break;
  case ATTR_K_VOLT_MIN_PULSE_WIDTH_LOW: s << "k_volt_min_pulse_width_low"; break;
  case ATTR_K_VOLT_NOCHANGE_FALL: s << "k_volt_nochange_fall"; break;
  case ATTR_K_VOLT_NOCHANGE_RISE: s << "k_volt_nochange_rise"; break;
  case ATTR_K_VOLT_PIN_CAP: s << "k_volt_pin_cap"; break;
  case ATTR_K_VOLT_RECOVERY_FALL: s << "k_volt_recovery_fall"; break;
  case ATTR_K_VOLT_RECOVERY_RISE: s << "k_volt_recovery_rise"; break;
  case ATTR_K_VOLT_REMOVAL_FALL: s << "k_volt_removal_fall"; break;
  case ATTR_K_VOLT_REMOVAL_RISE: s << "k_volt_removal_rise"; break;
  case ATTR_K_VOLT_RISE_TRANSITION: s << "k_volt_rise_transition"; break;
  case ATTR_K_VOLT_RISE_DELAY_INTERCEPT: s << "k_volt_rise_delay_intercept"; break;
  case ATTR_K_VOLT_RISE_PIN_RESISTANCE: s << "k_volt_rise_pin_resistance"; break;
  case ATTR_K_VOLT_RISE_PROPAGATION: s << "k_volt_rise_propagation"; break;
  case ATTR_K_VOLT_SETUP_FALL: s << "k_volt_setup_fall"; break;
  case ATTR_K_VOLT_SETUP_RISE: s << "k_volt_setup_rise"; break;
  case ATTR_K_VOLT_SKEW_FALL: s << "k_volt_skew_fall"; break;
  case ATTR_K_VOLT_SKEW_RISE: s << "k_volt_skew_rise"; break;
  case ATTR_K_VOLT_SLOPE_FALL: s << "k_volt_slope_fall"; break;
  case ATTR_K_VOLT_SLOPE_RISE: s << "k_volt_slope_rise"; break;
  case ATTR_K_VOLT_WIRE_CAP: s << "k_volt_wire_cap"; break;
  case ATTR_K_VOLT_WIRE_RES: s << "k_volt_wire_res"; break;
  case ATTR_LATCH_BANK: s << "latch_bank"; break;
  case ATTR_LATCH: s << "latch"; break;
  case ATTR_LEAKAGE_CURRENT: s << "leakage_current"; break;
  case ATTR_LEAKAGE_POWER_UNIT: s << "leakage_power_unit"; break;
  case ATTR_LEAKAGE_POWER: s << "leakage_power"; break;
  case ATTR_LIBRARY_FEATURES: s << "library_features"; break;
  case ATTR_LIBRARY: s << "library"; break;
  case ATTR_LU_TABLE_TEMPLATE: s << "lu_table_template"; break;
  case ATTR_LUT: s << "lut"; break;
  case ATTR_MAP_ONLY: s << "map_only"; break;
  case ATTR_MAX_CAPACITANCE: s << "max_capacitance"; break;
  case ATTR_MAX_FANOUT: s << "max_fanout"; break;
  case ATTR_MAX_INPUT_NOISE_WIDTH: s << "max_input_noise_width"; break;
  case ATTR_MAX_TRANS: s << "max_trans"; break;
  case ATTR_MAX_TRANSITION: s << "max_transition"; break;
  case ATTR_MEMBERS: s << "members"; break;
  case ATTR_MIN_CAPACITANCE: s << "min_capacitance"; break;
  case ATTR_MIN_FANOUT: s << "min_fanout"; break;
  case ATTR_MIN_INPUT_NOISE_WIDTH: s << "min_input_noise_width"; break;
  case ATTR_MIN_PERIOD: s << "min_period"; break;
  case ATTR_MIN_PULSE_WIDTH_HIGH: s << "min_pulse_width_high"; break;
  case ATTR_MIN_PULSE_WIDTH_LOW: s << "min_pulse_width_low"; break;
  case ATTR_MIN_PULSE_WIDTH: s << "min_pulse_width"; break;
  case ATTR_MIN_TRANSITION: s << "min_transition"; break;
  case ATTR_MINIMUM_PERIOD: s << "minimum_period"; break;
  case ATTR_MODE_DEFINITION: s << "mode_definition"; break;
  case ATTR_MULTICELL_PAD_PIN: s << "multicell_pad_pin"; break;
  case ATTR_NEXT_STATE: s << "next_state"; break;
  case ATTR_NEXTSTATE_TYPE: s << "nextstate_type"; break;
  case ATTR_NOISE_IMMUNITY_ABOVE_HIGH: s << "noise_immunity_above_high"; break;
  case ATTR_NOISE_IMMUNITY_BELOW_LOW: s << "noise_immunity_below_low"; break;
  case ATTR_NOISE_IMMUNITY_HIGH: s << "noise_immunity_high"; break;
  case ATTR_NOISE_IMMUNITY_LOW: s << "noise_immunity_low"; break;
  case ATTR_NOISE_LUT_TEMPLATE: s << "noise_lut_template"; break;
  case ATTR_NOM_CALC_MODE: s << "nom_calc_mode"; break;
  case ATTR_NOM_PROCESS: s << "nom_process"; break;
  case ATTR_NOM_TEMPERATURE: s << "nom_temperature"; break;
  case ATTR_NOM_VOLTAGE: s << "nom_voltage"; break;
  case ATTR_OPERATING_CONDITIONS: s << "operating_conditions"; break;
  case ATTR_ORDERS: s << "orders"; break;
  case ATTR_OUTPUT_CURRENT_TEMPLATE: s << "output_current_template"; break;
  case ATTR_OUTPUT_SIGNAL_LEVEL: s << "output_signal_level"; break;
  case ATTR_OUTPUT_THRESHOLD_PCT_FALL: s << "output_threshold_pct_fall"; break;
  case ATTR_OUTPUT_THRESHOLD_PCT_RISE: s << "output_threshold_pct_rise"; break;
  case ATTR_OUTPUT_VOLTAGE: s << "output_voltage"; break;
  case ATTR_PAD_CELL: s << "pad_cell"; break;
  case ATTR_PAD_TYPE: s << "pad_type"; break;
  case ATTR_PARAMETER1: s << "parameter1"; break;
  case ATTR_PARAMETER2: s << "parameter2"; break;
  case ATTR_PARAMETER3: s << "parameter3"; break;
  case ATTR_PARAMETER4: s << "parameter4"; break;
  case ATTR_PARAMETER5: s << "parameter5"; break;
  case ATTR_PART: s << "part"; break;
  case ATTR_PIECE_DEFINE: s << "piece_define"; break;
  case ATTR_PIECE_TYPE: s << "piece_type"; break;
  case ATTR_PIN_FUNC_TYPE: s << "pin_func_type"; break;
  case ATTR_PIN_OPPOSITE: s << "pin_opposite"; break;
  case ATTR_PIN: s << "pin"; break;
  case ATTR_POLY_TEMPLATE: s << "poly_template"; break;
  case ATTR_POWER_CELL_TYPE: s << "power_cell_type"; break;
  case ATTR_POWER_LEVEL: s << "power_level"; break;
  case ATTR_POWER_LUT_TEMPLATE: s << "power_lut_template"; break;
  case ATTR_POWER_POLY_TEMPLATE: s << "power_poly_template"; break;
  case ATTR_POWER_MODEL: s << "power_model"; break;
  case ATTR_POWER_RAIL: s << "power_rail"; break;
  case ATTR_POWER_SUPPLY_NAMESTRING: s << "power_supply_namestring"; break;
  case ATTR_POWER_SUPPLY: s << "power_supply"; break;
  case ATTR_POWER: s << "power"; break;
  case ATTR_PREFER_TIED: s << "prefer_tied"; break;
  case ATTR_PREFERRED: s << "preferred"; break;
  case ATTR_PREFERRED_INPUT_PAD_VOLTAGE: s << "preferred_input_pad_voltage"; break;
  case ATTR_PREFERRED_OUTPUT_PAD_SLEW_RATE_CONTROL: s << "preferred_output_pad_slew_rate_control"; break;
  case ATTR_PREFERRED_OUTPUT_PAD_VOLTAGE: s << "preferred_output_pad_voltage"; break;
  case ATTR_PRESET: s << "preset"; break;
  case ATTR_PRIMARY_OUTPUT: s << "primary_output"; break;
  case ATTR_PROCESS: s << "process"; break;
  case ATTR_PROPAGATED_NOISE_HEIGHT_ABOVE_HIGH: s << "propagated_noise_height_above_high"; break;
  case ATTR_PROPAGATED_NOISE_HEIGHT_BELOW_LOW: s << "propagated_noise_height_below_low"; break;
  case ATTR_PROPAGATED_NOISE_HEIGHT_HIGH: s << "propagated_noise_height_high"; break;
  case ATTR_PROPAGATED_NOISE_HEIGHT_LOW: s << "propagated_noise_height_low"; break;
  case ATTR_PROPAGATED_NOISE_PEAK_TIME_RATIO_ABOVE_HIGH: s << "propagated_noise_peak_time_ratio_above_high"; break;
  case ATTR_PROPAGATED_NOISE_PEAK_TIME_RATIO_BELOW_LOW: s << "propagated_noise_peak_time_ratio_below_low"; break;
  case ATTR_PROPAGATED_NOISE_PEAK_TIME_RATIO_HIGH: s << "propagated_noise_peak_time_ratio_high"; break;
  case ATTR_PROPAGATED_NOISE_PEAK_TIME_RATIO_LOW: s << "propagated_noise_peak_time_ratio_low"; break;
  case ATTR_PROPAGATED_NOISE_WIDTH_ABOVE_HIGH: s << "propagated_noise_width_above_high"; break;
  case ATTR_PROPAGATED_NOISE_WIDTH_BELOW_LOW: s << "propagated_noise_width_below_low"; break;
  case ATTR_PROPAGATED_NOISE_WIDTH_HIGH: s << "propagated_noise_width_high"; break;
  case ATTR_PROPAGATED_NOISE_WIDTH_LOW: s << "propagated_noise_width_low"; break;
  case ATTR_PROPAGATION_LUT_TEMPLATE: s << "propagation_lut_template"; break;
  case ATTR_PULLING_CURRENT: s << "pulling_current"; break;
  case ATTR_PULLING_RESISTANCE_UNIT: s << "pulling_resistance_unit"; break;
  case ATTR_PULLING_RESISTANCE: s << "pulling_resistance"; break;
  case ATTR_RAIL_CONNECTION: s << "rail_connection"; break;
  case ATTR_RELATED_BUS_EQUIVALENT: s << "related_bus_equivalent"; break;
  case ATTR_RELATED_BUS_PINS: s << "related_bus_pins"; break;
  case ATTR_RELATED_INPUTS: s << "related_inputs"; break;
  case ATTR_RELATED_OUTPUT_PIN: s << "related_output_pin"; break;
  case ATTR_RELATED_OUTPUTS: s << "related_outputs"; break;
  case ATTR_RELATED_PG_PIN: s << "related_pg_pin"; break;
  case ATTR_RELATED_PIN: s << "related_pin"; break;
  case ATTR_RESISTANCE: s << "resistance"; break;
  case ATTR_RESOURCE_USAGE: s << "resource_usage"; break;
  case ATTR_RETAIN_FALL_SLEW: s << "retain_fall_slew"; break;
  case ATTR_RETAIN_RISE_SLEW: s << "retain_rise_slew"; break;
  case ATTR_RETAINING_FALL: s << "retaining_fall"; break;
  case ATTR_RETAINING_RISE: s << "retaining_rise"; break;
  case ATTR_REVISION: s << "revision"; break;
  case ATTR_RISE_CAPACITANCE_RANGE: s << "rise_capacitance_range"; break;
  case ATTR_RISE_CAPACITANCE: s << "rise_capacitance"; break;
  case ATTR_RISE_CONSTRAINT: s << "rise_constraint"; break;
  case ATTR_RISE_CURRENT_SLOPE_AFTER_THRESHOLD: s << "rise_current_slope_after_threshold"; break;
  case ATTR_RISE_CURRENT_SLOPE_BEFORE_THRESHOLD: s << "rise_current_slope_before_threshold"; break;
  case ATTR_RISE_DELAY_INTERCEPT: s << "rise_delay_intercept"; break;
  case ATTR_RISE_PIN_RESISTANCE: s << "rise_pin_resistance"; break;
  case ATTR_RISE_POWER: s << "rise_power"; break;
  case ATTR_RISE_PROPAGATION: s << "rise_propagation"; break;
  case ATTR_RISE_RESISTANCE: s << "rise_resistance"; break;
  case ATTR_RISE_TIME_AFTER_THRESHOLD: s << "rise_time_after_threshold"; break;
  case ATTR_RISE_TIME_BEFORE_THRESHOLD: s << "rise_time_before_threshold"; break;
  case ATTR_RISE_TRANSITION_DEGRADATION: s << "rise_transition_degradation"; break;
  case ATTR_RISE_TRANSITION: s << "rise_transition"; break;
  case ATTR_RISING_TOGETHER_GROUP: s << "rising_together_group"; break;
  case ATTR_ROUTING_LAYERS: s << "routing_layers"; break;
  case ATTR_ROUTING_TRACK: s << "routing_track"; break;
  case ATTR_SCALED_CELL: s << "scaled_cell"; break;
  case ATTR_SCALING_FACTORS: s << "scaling_factors"; break;
  case ATTR_SDF_COND_END: s << "sdf_cond_end"; break;
  case ATTR_SDF_COND_START: s << "sdf_cond_start"; break;
  case ATTR_SDF_COND: s << "sdf_cond"; break;
  case ATTR_SDF_EDGES: s << "sdf_edges"; break;
  case ATTR_SIGNAL_TYPE: s << "signal_type"; break;
  case ATTR_SIMULATION: s << "simulation"; break;
  case ATTR_SINGLE_BIT_DEGENERATE: s << "single_bit_degenerate"; break;
  case ATTR_SLEW_CONTROL: s << "slew_control"; break;
  case ATTR_SLEW_DERATE_FROM_LIBRARY: s << "slew_derate_from_library"; break;
  case ATTR_SLEW_LOWER_THRESHOLD_PCT_FALL: s << "slew_lower_threshold_pct_fall"; break;
  case ATTR_SLEW_LOWER_THRESHOLD_PCT_RISE: s << "slew_lower_threshold_pct_rise"; break;
  case ATTR_SLEW_TYPE: s << "slew_type"; break;
  case ATTR_SLEW_UPPER_THRESHOLD_PCT_FALL: s << "slew_upper_threshold_pct_fall"; break;
  case ATTR_SLEW_UPPER_THRESHOLD_PCT_RISE: s << "slew_upper_threshold_pct_rise"; break;
  case ATTR_SLOPE_FALL: s << "slope_fall"; break;
  case ATTR_SLOPE_RISE: s << "slope_rise"; break;
  case ATTR_SLOPE: s << "slope"; break;
  case ATTR_STATE_FUNCTION: s << "state_function"; break;
  case ATTR_STATETABLE: s << "statetable"; break;
  case ATTR_STEADY_STATE_CURRENT_HIGH: s << "steady_state_current_high"; break;
  case ATTR_STEADY_STATE_CURRENT_LOW: s << "steady_state_current_low"; break;
  case ATTR_STEADY_STATE_CURRENT_TRISTATE: s << "steady_state_current_tristate"; break;
  case ATTR_SWITCHING_INTERVAL: s << "switching_interval"; break;
  case ATTR_SWITCHING_TOGETHER_GROUP: s << "switching_together_group"; break;
  case ATTR_TABLE: s << "table"; break;
  case ATTR_TECHNOLOGY: s << "technology"; break;
  case ATTR_TEMPERATURE: s << "temperature"; break;
  case ATTR_TEST_CELL: s << "test_cell"; break;
  case ATTR_TEST_OUTPUT_ONLY: s << "test_output_only"; break;
  case ATTR_THREE_STATE: s << "three_state"; break;
  case ATTR_TIME_UNIT: s << "time_unit"; break;
  case ATTR_TIMING_MODEL_TYPE: s << "timing_model_type"; break;
  case ATTR_TIMING_RANGE: s << "timing_range"; break;
  case ATTR_TIMING_SENSE: s << "timing_sense"; break;
  case ATTR_TIMING_TYPE: s << "timing_type"; break;
  case ATTR_TIMING: s << "timing"; break;
  case ATTR_TLATCH: s << "tlatch"; break;
  case ATTR_TREE_TYPE: s << "tree_type"; break;
  case ATTR_TYPE: s << "type"; break;
  case ATTR_USE_FOR_SIZE_ONLY: s << "use_for_size_only"; break;
  case ATTR_VALUE: s << "value"; break;
  case ATTR_VALUES: s << "values"; break;
  case ATTR_VARIABLE_1: s << "variable_1"; break;
  case ATTR_VARIABLE_2: s << "variable_2"; break;
  case ATTR_VARIABLE_3: s << "variable_3"; break;
  case ATTR_VHDL_NAME: s << "vhdl_name"; break;
  case ATTR_VIH: s << "vih"; break;
  case ATTR_VIL: s << "vil"; break;
  case ATTR_VIMAX: s << "vimax"; break;
  case ATTR_VIMIN: s << "vimin"; break;
  case ATTR_VOH: s << "voh"; break;
  case ATTR_VOL: s << "vol"; break;
  case ATTR_VOLTAGE_UNIT: s << "voltage_unit"; break;
  case ATTR_VOLTAGE: s << "voltage"; break;
  case ATTR_VOMAX: s << "vomax"; break;
  case ATTR_VOMIN: s << "vomin"; break;
  case ATTR_WHEN_END: s << "when_end"; break;
  case ATTR_WHEN_START: s << "when_start"; break;
  case ATTR_WHEN: s << "when"; break;
  case ATTR_WIRE_LOAD_FROM_AREA: s << "wire_load_from_area"; break;
  case ATTR_WIRE_LOAD_SELECTION: s << "wire_load_selection"; break;
  case ATTR_WIRE_LOAD_TABLE: s << "wire_load_table"; break;
  case ATTR_WIRE_LOAD: s << "wire_load"; break;
  case ATTR_X_FUNCTION: s << "x_function"; break;
  }
  return s;
}

END_NAMESPACE_YM_DOTLIB
